{"/home/travis/build/npmtest/node-npmtest-spdy/test.js":"/* istanbul instrument in package npmtest_spdy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spdy/lib.npmtest_spdy.js":"/* istanbul instrument in package npmtest_spdy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_spdy = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_spdy = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-spdy/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-spdy && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_spdy */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_spdy\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_spdy.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_spdy.rollup.js'] =\n            local.assetsDict['/assets.npmtest_spdy.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_spdy.__dirname + '/lib.npmtest_spdy.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy.js":"'use strict';\n\nvar spdy = exports;\n\n// Export tools\nspdy.handle = require('./spdy/handle');\nspdy.request = require('./spdy/request');\nspdy.response = require('./spdy/response');\nspdy.Socket = require('./spdy/socket');\n\n// Export client\nspdy.agent = require('./spdy/agent');\nspdy.Agent = spdy.agent.Agent;\nspdy.createAgent = spdy.agent.create;\n\n// Export server\nspdy.server = require('./spdy/server');\nspdy.Server = spdy.server.Server;\nspdy.PlainServer = spdy.server.PlainServer;\nspdy.createServer = spdy.server.create;\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/handle.js":"'use strict';\n\nvar assert = require('assert');\nvar thing = require('handle-thing');\nvar httpDeceiver = require('http-deceiver');\nvar util = require('util');\n\nfunction Handle(options, stream, socket) {\n  var state = {};\n  this._spdyState = state;\n\n  state.options = options || {};\n\n  state.stream = stream;\n  state.socket = null;\n  state.rawSocket = socket || stream.connection.socket;\n  state.deceiver = null;\n  state.ending = false;\n\n  var self = this;\n  thing.call(this, stream, {\n    getPeerName: function() {\n      return self._getPeerName();\n    },\n    close: function(callback) {\n      return self._closeCallback(callback);\n    }\n  });\n\n  if (!state.stream) {\n    this.on('stream', function(stream) {\n      state.stream = stream;\n    });\n  }\n}\nutil.inherits(Handle, thing);\nmodule.exports = Handle;\n\nHandle.create = function create(options, stream, socket) {\n  return new Handle(options, stream, socket);\n};\n\nHandle.prototype._getPeerName = function _getPeerName() {\n  var state = this._spdyState;\n\n  if (state.rawSocket._getpeername)\n    return state.rawSocket._getpeername();\n\n  return null;\n};\n\nHandle.prototype._closeCallback = function _closeCallback(callback) {\n  var state = this._spdyState;\n  var stream = state.stream;\n\n  if (state.ending) {\n    // The .end() method of the stream may be called by us or by the\n    // .shutdown() method in our super-class. If the latter has already been\n    // called, then calling the .end() method below will have no effect, with\n    // the result that the callback will never get executed, leading to an ever\n    // so subtle memory leak.\n    if (stream._writableState.finished) {\n      // NOTE: it is important to call `setImmediate` instead of `nextTick`,\n      // since this is how regular `handle.close()` works in node.js core.\n      //\n      // Using `nextTick` will lead to `net.Socket` emitting `close` before\n      // `end` on UV_EOF. This results in aborted request without `end` event.\n      setImmediate(callback);\n    } else if (stream._writableState.ending) {\n      stream.once('finish', function() {\n        callback(null);\n      });\n    } else {\n      stream.end(callback);\n    }\n  } else {\n    stream.abort(callback);\n  }\n\n  // Only a single end is allowed\n  state.ending = false;\n};\n\nHandle.prototype.getStream = function getStream(callback) {\n  var state = this._spdyState;\n\n  if (!callback) {\n    assert(state.stream);\n    return state.stream;\n  }\n\n  if (state.stream) {\n    process.nextTick(function() {\n      callback(state.stream);\n    });\n    return;\n  }\n\n  this.on('stream', callback);\n};\n\nHandle.prototype.assignSocket = function assignSocket(socket, options) {\n  var state = this._spdyState;\n\n  state.socket = socket;\n  state.deceiver = httpDeceiver.create(socket, options);\n\n  function onStreamError(err) {\n    state.socket.emit('error', err);\n  }\n\n  this.getStream(function(stream) {\n    stream.on('error', onStreamError);\n  });\n};\n\nHandle.prototype.assignClientRequest = function assignClientRequest(req) {\n  var state = this._spdyState;\n  var oldEnd = req.end;\n  var oldSend = req._send;\n\n  // Catch the headers before request will be sent\n  var self = this;\n\n  // For old nodes\n  if (thing.mode !== 'modern') {\n    req.end = function end() {\n      this.end = oldEnd;\n\n      this._send('');\n\n      return this.end.apply(this, arguments);\n    };\n  }\n\n  req._send = function send(data) {\n    this._headerSent = true;\n\n    // for v0.10 and below, otherwise it will set `hot = false` and include\n    // headers in first write\n    this._header = 'ignore me';\n\n    // To prevent exception\n    this.connection = state.socket;\n\n    // It is very important to leave this here, otherwise it will be executed\n    // on a next tick, after `_send` will perform write\n    self.getStream(function(stream) {\n      stream.send();\n    });\n\n    // We are ready to create stream\n    self.emit('needStream');\n\n    req._send = oldSend;\n\n    // Ignore empty writes\n    if (req.method === 'GET' && data.length === 0)\n      return;\n\n    return req._send.apply(this, arguments);\n  };\n\n  // No chunked encoding\n  req.useChunkedEncodingByDefault = false;\n\n  req.on('finish', function() {\n    req.socket.end();\n  });\n};\n\nHandle.prototype.assignRequest = function assignRequest(req) {\n  // Emit trailing headers\n  this.getStream(function(stream) {\n    stream.on('headers', function(headers) {\n      req.emit('trailers', headers);\n    });\n  });\n};\n\nHandle.prototype.assignResponse = function assignResponse(res) {\n  var self = this;\n\n  res.addTrailers = function addTrailers(headers) {\n    self.getStream(function(stream) {\n      stream.sendHeaders(headers);\n    });\n  };\n};\n\nHandle.prototype._transformHeaders = function _transformHeaders(kind, headers) {\n  var state = this._spdyState;\n\n  var res = {};\n  var keys = Object.keys(headers);\n\n  if (kind === 'request' && state.options['x-forwarded-for']) {\n    var xforwarded = state.stream.connection.getXForwardedFor();\n    if (xforwarded !== null)\n      res['x-forwarded-for'] = xforwarded;\n  }\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = headers[key];\n\n    if (key === ':authority')\n      res.host = value;\n    if (/^:/.test(key))\n      continue;\n\n    res[key] = value;\n  }\n  return res;\n};\n\nHandle.prototype.emitRequest = function emitRequest() {\n  var state = this._spdyState;\n  var stream = state.stream;\n\n  state.deceiver.emitRequest({\n    method: stream.method,\n    path: stream.path,\n    headers: this._transformHeaders('request', stream.headers)\n  });\n};\n\nHandle.prototype.emitResponse = function emitResponse(status, headers) {\n  var state = this._spdyState;\n\n  state.deceiver.emitResponse({\n    status: status,\n    headers: this._transformHeaders('response', headers)\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/request.js":"'use strict';\n\nfunction attachPush(req) {\n  var handle = req.socket._handle;\n\n  handle.getStream(function(stream) {\n    stream.on('pushPromise', function(push) {\n      req.emit('push', push);\n    });\n  });\n}\n\nexports.onNewListener = function onNewListener(type) {\n  var req = this;\n\n  if (type !== 'push')\n    return;\n\n  // Not first listener\n  if (req.listeners('push').length !== 0)\n    return;\n\n  if (!req.socket) {\n    req.on('socket', function() {\n      attachPush(req);\n    });\n    return;\n  }\n\n  attachPush(req);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/response.js":"'use strict';\n\n// NOTE: Mostly copy paste from node\nexports.writeHead = function writeHead(statusCode, reason, obj) {\n  var headers;\n\n  if (typeof reason === 'string') {\n    // writeHead(statusCode, reasonPhrase[, headers])\n    this.statusMessage = reason;\n  } else {\n    // writeHead(statusCode[, headers])\n    this.statusMessage =\n      this.statusMessage || 'unknown';\n    obj = reason;\n  }\n  this.statusCode = statusCode;\n\n  if (this._headers) {\n    // Slow-case: when progressive API and header fields are passed.\n    if (obj) {\n      var keys = Object.keys(obj);\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        if (k) this.setHeader(k, obj[k]);\n      }\n    }\n    // only progressive api is used\n    headers = this._renderHeaders();\n  } else {\n    // only writeHead() called\n    headers = obj;\n  }\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (100 <= statusCode && statusCode <= 199)) {\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response,\n    // consisting only of the Status-Line and optional headers, and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  // Implicit headers sent!\n  this._header = true;\n  this._headerSent = true;\n\n  if (this.socket._handle)\n    this.socket._handle._spdyState.stream.respond(this.statusCode, headers);\n};\n\nexports.end = function end(data, encoding, callback) {\n  if (!this._headerSent)\n    this.writeHead(this.statusCode);\n\n  if (!this.socket._handle)\n    return;\n\n  // Compatibility with Node.js core\n  this.finished = true;\n\n  var self = this;\n  var handle = this.socket._handle;\n  handle._spdyState.ending = true;\n  this.socket.end(data, encoding, function() {\n    self.constructor.prototype.end.call(self, '', 'utf8', callback);\n  });\n};\n\nexports.push = function push(path, headers, callback) {\n  var frame = {\n    path: path,\n    method: headers.method ? headers.method.toString() : 'GET',\n    status: headers.status ? parseInt(headers.status, 10) : 200,\n    host: this._req.headers.host,\n    headers: headers.request,\n    response: headers.response\n  };\n\n  var stream = this.spdyStream;\n  return stream.pushPromise(frame, callback);\n};\n\nexports.writeContinue = function writeContinue(callback) {\n  if (this.socket._handle)\n    this.socket._handle._spdyState.stream.respond(100, {}, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/socket.js":"'use strict';\n\nvar util = require('util');\nvar net = require('net');\n\nfunction Socket(parent, options) {\n  net.Socket.call(this, options);\n\n  var state = {};\n\n  this._spdyState = state;\n\n  state.parent = parent;\n\n  this.servername = parent.servername;\n  this.npnProtocol = parent.npnProtocol;\n  this.alpnProtocol = parent.alpnProtocol;\n  this.authorized = parent.authorized;\n  this.authorizationError = parent.authorizationError;\n  this.encrypted = true;\n}\nutil.inherits(Socket, net.Socket);\n\nmodule.exports = Socket;\n\nvar methods = [\n  'renegotiate', 'setMaxSendFragment', 'getTLSTicket', 'setServername',\n  'setSession', 'getPeerCertificate', 'getSession', 'isSessionReused',\n  'getCipher', 'getEphemeralKeyInfo'\n];\n\nmethods.forEach(function(method) {\n  Socket.prototype[method] = function methodWrap() {\n    var parent = this._spdyState.parent;\n    return parent[method].apply(parent, arguments);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/agent.js":"'use strict';\n\nvar assert = require('assert');\nvar http = require('http');\nvar https = require('https');\nvar net = require('net');\nvar util = require('util');\nvar transport = require('spdy-transport');\nvar debug = require('debug')('spdy:client');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar spdy = require('../spdy');\n\nvar mode = /^v0\\.8\\./.test(process.version) ? 'rusty' :\n           /^v0\\.(9|10)\\./.test(process.version) ? 'old' :\n           /^v0\\.12\\./.test(process.version) ? 'normal' :\n           'modern';\n\nvar proto = {};\n\nfunction instantiate(base) {\n  function Agent(options) {\n    this._init(base, options);\n  }\n  util.inherits(Agent, base);\n\n  Agent.create = function create(options) {\n    return new Agent(options);\n  };\n\n  Object.keys(proto).forEach(function(key) {\n    Agent.prototype[key] = proto[key];\n  });\n\n  return Agent;\n}\n\nproto._init = function _init(base, options) {\n  base.call(this, options);\n\n  var state = {};\n  this._spdyState = state;\n\n  state.host = options.host;\n  state.options = options.spdy || {};\n  state.secure = this instanceof https.Agent;\n  state.fallback = false;\n  state.createSocket = this._getCreateSocket();\n  state.socket = null;\n  state.connection = null;\n\n  // No chunked encoding\n  this.keepAlive = false;\n\n  var self = this;\n  this._connect(options, function(err, connection) {\n    if (err)\n      return self.emit('error', err);\n\n    state.connection = connection;\n    self.emit('_connect');\n  });\n};\n\nproto._getCreateSocket = function _getCreateSocket() {\n  // Find super's `createSocket` method\n  var createSocket;\n  var cons = this.constructor.super_;\n  do {\n    createSocket = cons.prototype.createSocket;\n\n    if (cons.super_ === EventEmitter || !cons.super_)\n      break;\n    cons = cons.super_;\n  } while (!createSocket);\n  if (!createSocket)\n    createSocket = http.Agent.prototype.createSocket;\n\n  assert(createSocket, '.createSocket() method not found');\n\n  return createSocket;\n};\n\nproto._connect = function _connect(options, callback) {\n  var state = this._spdyState;\n\n  var protocols = state.options.protocols || [\n    'h2',\n    'spdy/3.1', 'spdy/3', 'spdy/2',\n    'http/1.1', 'http/1.0'\n  ];\n\n  // TODO(indutny): reconnect automatically?\n  var socket = this.createConnection(util._extend({\n    NPNProtocols: protocols,\n    ALPNProtocols: protocols,\n    servername: options.servername || options.host\n  }, options));\n  state.socket = socket;\n\n  socket.setNoDelay(true);\n\n  function onError(err) {\n    return callback(err);\n  }\n  socket.on('error', onError);\n\n  socket.on(state.secure ? 'secureConnect' : 'connect', function() {\n    socket.removeListener('error', onError);\n\n    var protocol;\n    if (state.secure) {\n      protocol = socket.npnProtocol ||\n                 socket.alpnProtocol ||\n                 state.options.protocol;\n    } else {\n      protocol = state.options.protocol;\n    }\n\n    // HTTP server - kill socket and switch to the fallback mode\n    if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {\n      debug('activating fallback');\n      socket.destroy();\n      state.fallback = true;\n      return;\n    }\n\n    debug('connected protocol=%j', protocol);\n    var connection = transport.connection.create(socket, util._extend({\n      protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',\n      isServer: false\n    }, state.options.connection || {}));\n\n    // Set version when we are certain\n    if (protocol === 'h2') {\n      connection.start(4);\n    } else if (protocol === 'spdy/3.1') {\n      connection.start(3.1);\n    } else if (protocol === 'spdy/3') {\n      connection.start(3);\n    } else if (protocol === 'spdy/2') {\n      connection.start(2);\n    } else {\n      socket.destroy();\n      callback(new Error('Unexpected protocol: ' + protocol));\n      return;\n    }\n\n    if (state.options['x-forwarded-for'] !== undefined)\n      connection.sendXForwardedFor(state.options['x-forwarded-for']);\n\n    callback(null, connection);\n  });\n};\n\nproto._createSocket = function _createSocket(req, options, callback) {\n  var state = this._spdyState;\n  if (state.fallback)\n    return state.createSocket(req, options);\n\n  var handle = spdy.handle.create(null, null, state.socket);\n\n  var socketOptions = {\n    handle: handle,\n    allowHalfOpen: true\n  };\n\n  var socket;\n  if (state.secure)\n    socket = new spdy.Socket(state.socket, socketOptions);\n  else\n    socket = new net.Socket(socketOptions);\n\n  handle.assignSocket(socket);\n  handle.assignClientRequest(req);\n\n  // Create stream only once `req.end()` is called\n  var self = this;\n  handle.once('needStream', function() {\n    if (state.connection === null) {\n      self.once('_connect', function() {\n        handle.setStream(self._createStream(req, handle));\n      });\n    } else {\n      handle.setStream(self._createStream(req, handle));\n    }\n  });\n\n  // Yes, it is in reverse\n  req.on('response', function(res) {\n    handle.assignRequest(res);\n  });\n  handle.assignResponse(req);\n\n  // Handle PUSH\n  req.addListener('newListener', spdy.request.onNewListener);\n\n  // For v0.8\n  socket.readable = true;\n  socket.writable = true;\n\n  if (callback)\n    return callback(null, socket);\n\n  return socket;\n};\n\nif (mode === 'modern' || mode === 'normal') {\n  proto.createSocket = proto._createSocket;\n} else {\n  proto.createSocket = function createSocket(name, host, port, addr, req) {\n    var state = this._spdyState;\n    if (state.fallback)\n      return state.createSocket(name, host, port, addr, req);\n\n    return this._createSocket(req, {\n      host: host,\n      port: port\n    });\n  };\n}\n\nproto._createStream = function _createStream(req, handle) {\n  var state = this._spdyState;\n\n  var self = this;\n  return state.connection.reserveStream({\n    method: req.method,\n    path: req.path,\n    headers: req._headers,\n    host: state.host\n  }, function(err, stream) {\n    if (err)\n      return self.emit('error', err);\n\n    stream.on('response', function(status, headers) {\n      handle.emitResponse(status, headers);\n    });\n  });\n};\n\n// Public APIs\n\nproto.close = function close(callback) {\n  var state = this._spdyState;\n\n  if (state.connection === null) {\n    this.once('_connect', function() {\n      this.close(callback);\n    });\n    return;\n  }\n\n  state.connection.end(callback);\n};\n\nexports.Agent = instantiate(https.Agent);\nexports.PlainAgent = instantiate(http.Agent);\n\nexports.create = function create(base, options) {\n  if (typeof base === 'object') {\n    options = base;\n    base = null;\n  }\n\n  if (base)\n    return instantiate(base).create(options);\n\n  if (options.spdy && options.spdy.plain)\n    return exports.PlainAgent.create(options);\n  else\n    return exports.Agent.create(options);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport.js":"'use strict';\n\nvar transport = exports;\n\n// Exports utils\ntransport.utils = require('./spdy-transport/utils');\n\n// Export parser&framer\ntransport.protocol = {};\ntransport.protocol.base = require('./spdy-transport/protocol/base');\ntransport.protocol.spdy = require('./spdy-transport/protocol/spdy');\ntransport.protocol.http2 = require('./spdy-transport/protocol/http2');\n\n// Window\ntransport.Window = require('./spdy-transport/window');\n\n// Priority Tree\ntransport.Priority = require('./spdy-transport/priority');\n\n// Export Connection and Stream\ntransport.Stream = require('./spdy-transport/stream').Stream;\ntransport.Connection = require('./spdy-transport/connection').Connection;\n\n// Just for `transport.connection.create()`\ntransport.connection = transport.Connection;\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/utils.js":"'use strict';\n\nvar util = require('util');\n\nfunction QueueItem() {\n  this.prev = null;\n  this.next = null;\n}\nexports.QueueItem = QueueItem;\n\nfunction Queue() {\n  QueueItem.call(this);\n\n  this.prev = this;\n  this.next = this;\n}\nutil.inherits(Queue, QueueItem);\nexports.Queue = Queue;\n\nQueue.prototype.insertTail = function insertTail(item) {\n  item.prev = this.prev;\n  item.next = this;\n  item.prev.next = item;\n  item.next.prev = item;\n};\n\nQueue.prototype.remove = function remove(item) {\n  var next = item.next;\n  var prev = item.prev;\n\n  item.next = item;\n  item.prev = item;\n  next.prev = prev;\n  prev.next = next;\n};\n\nQueue.prototype.head = function head() {\n  return this.next;\n};\n\nQueue.prototype.tail = function tail() {\n  return this.prev;\n};\n\nQueue.prototype.isEmpty = function isEmpty() {\n  return this.next === this;\n};\n\nQueue.prototype.isRoot = function isRoot(item) {\n  return this === item;\n};\n\nfunction LockStream(stream) {\n  this.locked = false;\n  this.queue = [];\n  this.stream = stream;\n}\nexports.LockStream = LockStream;\n\nLockStream.prototype.write = function write(chunks, callback) {\n  var self = this;\n\n  // Do not let it interleave\n  if (this.locked) {\n    this.queue.push(function() {\n      return self.write(chunks, callback);\n    });\n    return;\n  }\n\n  this.locked = true;\n\n  function done(err, chunks) {\n    self.stream.removeListener('error', done);\n\n    self.locked = false;\n    if (self.queue.length > 0)\n      self.queue.shift()();\n    callback(err, chunks);\n  }\n\n  this.stream.on('error', done);\n\n  // Accumulate all output data\n  var output = [];\n  function onData(chunk) {\n    output.push(chunk);\n  }\n  this.stream.on('data', onData);\n\n  function next(err) {\n    self.stream.removeListener('data', onData);\n    if (err)\n      return done(err);\n\n    done(null, output);\n  }\n\n  for (var i = 0; i < chunks.length - 1; i++)\n    this.stream.write(chunks[i]);\n\n  if (chunks.length > 0)\n    this.stream.write(chunks[i], next);\n  else\n    process.nextTick(next);\n\n  if (this.stream.execute) {\n    this.stream.execute(function(err) {\n      if (err)\n        return done(err);\n    });\n  }\n};\n\n// Just finds the place in array to insert\nfunction binaryLookup(list, item, compare) {\n  var start = 0;\n  var end = list.length;\n\n  while (start < end) {\n    var pos = (start + end) >> 1;\n    var cmp = compare(item, list[pos]);\n\n    if (cmp === 0) {\n      start = pos;\n      end = pos;\n      break;\n    } else if (cmp < 0) {\n      end = pos;\n    } else {\n      start = pos + 1;\n    }\n  }\n\n  return start;\n}\nexports.binaryLookup = binaryLookup;\n\nfunction binaryInsert(list, item, compare) {\n  var index = binaryLookup(list, item, compare);\n\n  list.splice(index, 0, item);\n}\nexports.binaryInsert = binaryInsert;\n\nfunction binarySearch(list, item, compare) {\n  var index = binaryLookup(list, item, compare);\n\n  if (index >= list.length)\n    return -1;\n\n  if (compare(item, list[index]) === 0)\n    return index;\n\n  return -1;\n}\nexports.binarySearch = binarySearch;\n\nfunction Timeout(object) {\n  this.delay = 0;\n  this.timer = null;\n  this.object = object;\n}\nexports.Timeout = Timeout;\n\nTimeout.prototype.set = function set(delay, callback) {\n  this.delay = delay;\n  this.reset();\n  if (!callback)\n    return;\n\n  if (this.delay === 0)\n    this.object.removeListener('timeout', callback);\n  else\n    this.object.once('timeout', callback);\n};\n\nTimeout.prototype.reset = function reset() {\n  if (this.timer !== null) {\n    clearTimeout(this.timer);\n    this.timer = null;\n  }\n\n  if (this.delay === 0)\n    return;\n\n  var self = this;\n  this.timer = setTimeout(function() {\n    self.timer = null;\n    self.object.emit('timeout');\n  }, this.delay);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/index.js":"'use strict';\n\nexports.utils = require('./utils');\nexports.constants = require('./constants');\nexports.Scheduler = require('./scheduler');\nexports.Parser = require('./parser');\nexports.Framer = require('./framer');\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/utils.js":"'use strict';\n\nvar utils = exports;\n\nvar util = require('util');\n\nfunction ProtocolError(code, message) {\n  this.code = code;\n  this.message = message;\n}\nutil.inherits(ProtocolError, Error);\nutils.ProtocolError = ProtocolError;\n\nutils.error = function error(code, message) {\n  return new ProtocolError(code, message);\n};\n\nutils.reverse = function reverse(object) {\n  var result = []\n\n  Object.keys(object).forEach(function(key) {\n    result[object[key] | 0] = key;\n  });\n\n  return result;\n};\n\n// weight [1, 36] <=> priority [0, 7]\n// This way weight=16 is preserved and has priority=3\nutils.weightToPriority = function weightToPriority(weight) {\n  return ((Math.min(35, (weight - 1)) / 35) * 7) | 0;\n};\n\nutils.priorityToWeight = function priorityToWeight(priority) {\n  return (((priority / 7) * 35) | 0) + 1;\n};\n\n// Copy-Paste from node\nexports.addHeaderLine = function addHeaderLine(field, value, dest) {\n  field = field.toLowerCase();\n  if (/^:/.test(field)) {\n    dest[field] = value;\n    return;\n  }\n\n  switch (field) {\n    // Array headers:\n    case 'set-cookie':\n      if (dest[field] !== undefined) {\n        dest[field].push(value);\n      } else {\n        dest[field] = [ value ];\n      }\n      break;\n\n    /* eslint-disable max-len */\n    // list is taken from:\n    /* eslint-enable max-len */\n    case 'content-type':\n    case 'content-length':\n    case 'user-agent':\n    case 'referer':\n    case 'host':\n    case 'authorization':\n    case 'proxy-authorization':\n    case 'if-modified-since':\n    case 'if-unmodified-since':\n    case 'from':\n    case 'location':\n    case 'max-forwards':\n      // drop duplicates\n      if (dest[field] === undefined)\n        dest[field] = value;\n      break;\n\n    case 'cookie':\n      // make semicolon-separated list\n      if (dest[field] !== undefined) {\n        dest[field] += '; ' + value;\n      } else {\n        dest[field] = value;\n      }\n      break;\n\n    default:\n      // make comma-separated list\n      if (dest[field] !== undefined) {\n        dest[field] += ', ' + value;\n      } else {\n        dest[field] = value;\n      }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/constants.js":"exports.DEFAULT_METHOD = 'GET';\nexports.DEFAULT_HOST = 'localhost';\nexports.MAX_PRIORITY_STREAMS = 100;\nexports.DEFAULT_MAX_CHUNK = 8 * 1024;\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/scheduler.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar utils = transport.utils;\n\nvar assert = require('assert');\nvar util = require('util');\nvar debug = require('debug')('spdy:scheduler');\nvar Readable = require('readable-stream').Readable;\n\n/*\n * We create following structure in `pending`:\n * [ [ id = 0 ], [ id = 1 ], [ id = 2 ], [ id = 0 ] ]\n *     chunks      chunks      chunks      chunks\n *     chunks                  chunks\n *     chunks\n *\n * Then on the `.tick()` pass we pick one chunks from each item and remove the\n * item if it is empty:\n *\n * [ [ id = 0 ], [ id = 2 ] ]\n *     chunks      chunks\n *     chunks\n *\n * Writing out: chunks for 0, chunks for 1, chunks for 2, chunks for 0\n *\n * This way data is interleaved between the different streams.\n */\n\nfunction Scheduler(options) {\n  Readable.call(this);\n\n  // Pretty big window by default\n  this.window = 0.25;\n\n  if (options && options.window)\n    this.window = options.window;\n\n  this.sync = [];\n  this.list = [];\n  this.count = 0;\n  this.pendingTick = false;\n}\nutil.inherits(Scheduler, Readable);\nmodule.exports = Scheduler;\n\n// Just for testing, really\nScheduler.create = function create(options) {\n  return new Scheduler(options);\n};\n\nfunction insertCompare(a, b) {\n  return a.priority === b.priority ?\n      a.stream - b.stream :\n      b.priority - a.priority;\n}\n\nScheduler.prototype.schedule = function schedule(data) {\n  var priority = data.priority;\n  var stream = data.stream;\n  var chunks = data.chunks;\n\n  // Synchronous frames should not be interleaved\n  if (priority === false) {\n    debug('queue sync', chunks);\n    this.sync.push(data);\n    this.count += chunks.length;\n\n    this._read();\n    return;\n  }\n\n  debug('queue async priority=%d stream=%d', priority, stream, chunks);\n  var item = new SchedulerItem(stream, priority);\n  var index = utils.binaryLookup(this.list, item, insertCompare);\n\n  // Push new item\n  if (index >= this.list.length || insertCompare(this.list[index], item) !== 0)\n    this.list.splice(index, 0, item);\n  // Coalesce\n  else\n    item = this.list[index];\n\n  item.push(data);\n\n  this.count += chunks.length;\n\n  this._read();\n};\n\nScheduler.prototype._read = function _read() {\n  if (this.count === 0)\n    return;\n\n  if (this.pendingTick)\n    return;\n  this.pendingTick = true;\n\n  var self = this;\n  process.nextTick(function() {\n    self.pendingTick = false;\n    self.tick();\n  });\n};\n\nScheduler.prototype.tick = function tick() {\n  // No luck for async frames\n  if (!this.tickSync())\n    return false;\n\n  return this.tickAsync();\n};\n\nScheduler.prototype.tickSync = function tickSync() {\n  // Empty sync queue first\n  var sync = this.sync;\n  var res = true;\n  this.sync = [];\n  for (var i = 0; i < sync.length; i++) {\n    var item = sync[i];\n    debug('tick sync pending=%d', this.count, item.chunks);\n    for (var j = 0; j < item.chunks.length; j++) {\n      this.count--;\n      res = this.push(item.chunks[j]);\n    }\n    debug('after tick sync pending=%d', this.count);\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback)\n      item.callback(null);\n  }\n  return res;\n};\n\nScheduler.prototype.tickAsync = function tickAsync() {\n  var res = true;\n  var list = this.list;\n  if (list.length === 0)\n    return res;\n\n  var startPriority = list[0].priority;\n  for (var index = 0; list.length > 0; index++) {\n    // Loop index\n    index %= list.length;\n    if (startPriority - list[index].priority > this.window)\n      index = 0;\n    debug('tick async index=%d start=%d', index, startPriority);\n\n    var current = list[index];\n    var item = current.shift();\n\n    if (current.isEmpty()) {\n      list.splice(index, 1);\n      if (index === 0 && list.length > 0)\n        startPriority = list[0].priority;\n      index--;\n    }\n\n    debug('tick async pending=%d', this.count, item.chunks);\n    for (var i = 0; i < item.chunks.length; i++) {\n      this.count--;\n      res = this.push(item.chunks[i]);\n    }\n    debug('after tick pending=%d', this.count);\n\n    // TODO(indutny): figure out the way to invoke callback on actual write\n    if (item.callback)\n      item.callback(null);\n    if (!res)\n      break;\n  }\n\n  return res;\n};\n\nScheduler.prototype.dump = function dump() {\n  this.tickSync();\n\n  // Write everything out\n  while (!this.tickAsync()) {\n    // Intentional no-op\n  }\n  assert.equal(this.count, 0);\n};\n\nfunction SchedulerItem(stream, priority) {\n  this.stream = stream;\n  this.priority = priority;\n  this.queue = [];\n}\n\nSchedulerItem.prototype.push = function push(chunks) {\n  this.queue.push(chunks);\n};\n\nSchedulerItem.prototype.shift = function shift() {\n  return this.queue.shift();\n};\n\nSchedulerItem.prototype.isEmpty = function isEmpty() {\n  return this.queue.length === 0;\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/parser.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\n\nvar util = require('util');\nvar utils = require('./').utils;\nvar OffsetBuffer = require('obuf');\nvar Transform = require('readable-stream').Transform;\n\nfunction Parser(options) {\n  Transform.call(this, {\n    readableObjectMode: true\n  });\n\n  this.buffer = new OffsetBuffer();\n  this.partial = false;\n  this.waiting = 0;\n\n  this.window = options.window;\n\n  this.version = null;\n  this.decompress = null;\n  this.dead = false;\n}\nmodule.exports = Parser;\nutil.inherits(Parser, Transform);\n\nParser.prototype.error = utils.error;\n\nParser.prototype.kill = function kill() {\n  this.dead = true;\n};\n\nParser.prototype._transform = function transform(data, encoding, cb) {\n  if (!this.dead)\n    this.buffer.push(data);\n\n  this._consume(cb);\n};\n\nParser.prototype._consume = function _consume(cb) {\n  var self = this;\n\n  function next(err, frame) {\n    if (err)\n      return cb(err);\n\n    if (Array.isArray(frame)) {\n      for (var i = 0; i < frame.length; i++)\n        self.push(frame[i]);\n    } else if (frame) {\n      self.push(frame);\n    }\n\n    // Consume more packets\n    if (!sync)\n      return self._consume(cb);\n\n    process.nextTick(function() {\n      self._consume(cb);\n    });\n  }\n\n  if (this.dead)\n    return cb();\n\n\n  if (this.buffer.size < this.waiting) {\n    // No data at all\n    if (this.buffer.size === 0)\n      return cb();\n\n    // Partial DATA frame or something that we can process partially\n    if (this.partial) {\n      var partial = this.buffer.clone(this.buffer.size);\n      this.buffer.skip(partial.size);\n      this.waiting -= partial.size;\n\n      this.executePartial(partial, next);\n      return;\n    }\n\n    // We shall not do anything until we get all expected data\n    return cb();\n  }\n\n  var sync = true;\n\n  var content = this.buffer.clone(this.waiting);\n  this.buffer.skip(this.waiting);\n\n  this.execute(content, next);\n  sync = false;\n};\n\nParser.prototype.setVersion = function setVersion(version) {\n  this.version = version;\n  this.emit('version', version);\n};\n\nParser.prototype.setCompression = function setCompresion(pair) {\n  this.decompress = new transport.utils.LockStream(pair.decompress);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/base/framer.js":"'use strict';\n\nvar util = require('util');\n\nvar transport = require('../../../spdy-transport');\nvar base = require('./');\nvar Scheduler = base.Scheduler;\n\nfunction Framer(options) {\n  Scheduler.call(this);\n\n  this.version = null;\n  this.compress = null;\n  this.window = options.window;\n  this.timeout = options.timeout;\n\n  // Wait for `enablePush`\n  this.pushEnabled = null;\n}\nutil.inherits(Framer, Scheduler);\nmodule.exports = Framer;\n\nFramer.prototype.setVersion = function setVersion(version) {\n  this.version = version;\n  this.emit('version');\n};\n\nFramer.prototype.setCompression = function setCompresion(pair) {\n  this.compress = new transport.utils.LockStream(pair.compress);\n};\n\nFramer.prototype.enablePush = function enablePush(enable) {\n  this.pushEnabled = enable;\n  this.emit('_pushEnabled');\n};\n\nFramer.prototype._checkPush = function _checkPush(callback) {\n  if (this.pushEnabled === null) {\n    this.once('_pushEnabled', function() {\n      this._checkPush(callback);\n    });\n    return;\n  }\n\n  var self = this;\n  var err = null;\n  if (!this.pushEnabled)\n    err = new Error('PUSH_PROMISE disabled by other side');\n  process.nextTick(function() {\n    return callback(err);\n  });\n};\n\nFramer.prototype._resetTimeout = function _resetTimeout() {\n  if (this.timeout)\n    this.timeout.reset();\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/index.js":"'use strict';\n\nexports.name = 'spdy';\n\nexports.dictionary = require('./dictionary');\nexports.constants = require('./constants');\nexports.parser = require('./parser');\nexports.framer = require('./framer');\nexports.compressionPool = require('./zlib-pool');\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/dictionary.js":"'use strict';\n\nvar Buffer = require('buffer').Buffer;\n\nvar dictionary = {};\nmodule.exports = dictionary;\n\ndictionary[2] = new Buffer([\n  'optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-',\n  'languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi',\n  'f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser',\n  '-agent10010120020120220320420520630030130230330430530630740040140240340440',\n  '5406407408409410411412413414415416417500501502503504505accept-rangesageeta',\n  'glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic',\n  'ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran',\n  'sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati',\n  'oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo',\n  'ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe',\n  'pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic',\n  'ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1',\n  '.1statusversionurl\\x00'\n].join(''));\n\ndictionary[3] = new Buffer([\n  0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69,  // ....opti\n  0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68,  // ons....h\n  0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70,  // ead....p\n  0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70,  // ost....p\n  0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65,  // ut....de\n  0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05,  // lete....\n  0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00,  // trace...\n  0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00,  // .accept.\n  0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70,  // ...accep\n  0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,  // t-charse\n  0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63,  // t....acc\n  0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,  // ept-enco\n  0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f,  // ding....\n  0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c,  // accept-l\n  0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00,  // anguage.\n  0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70,  // ...accep\n  0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,  // t-ranges\n  0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00,  // ....age.\n  0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77,  // ...allow\n  0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68,  // ....auth\n  0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,  // orizatio\n  0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63,  // n....cac\n  0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72,  // he-contr\n  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f,  // ol....co\n  0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,  // nnection\n  0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74,  // ....cont\n  0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65,  // ent-base\n  0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74,  // ....cont\n  0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,  // ent-enco\n  0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10,  // ding....\n  0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d,  // content-\n  0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,  // language\n  0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74,  // ....cont\n  0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67,  // ent-leng\n  0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f,  // th....co\n  0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f,  // ntent-lo\n  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,  // cation..\n  0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,  // ..conten\n  0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00,  // t-md5...\n  0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,  // .content\n  0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00,  // -range..\n  0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,  // ..conten\n  0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,  // t-type..\n  0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00,  // ..date..\n  0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00,  // ..etag..\n  0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,  // ..expect\n  0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69,  // ....expi\n  0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66,  // res....f\n  0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68,  // rom....h\n  0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69,  // ost....i\n  0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00,  // f-match.\n  0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f,  // ...if-mo\n  0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73,  // dified-s\n  0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d,  // ince....\n  0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d,  // if-none-\n  0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00,  // match...\n  0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67,  // .if-rang\n  0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d,  // e....if-\n  0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69,  // unmodifi\n  0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65,  // ed-since\n  0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74,  // ....last\n  0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65,  // -modifie\n  0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63,  // d....loc\n  0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,  // ation...\n  0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72,  // .max-for\n  0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00,  // wards...\n  0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00,  // .pragma.\n  0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79,  // ...proxy\n  0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,  // -authent\n  0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,  // icate...\n  0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61,  // .proxy-a\n  0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,  // uthoriza\n  0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05,  // tion....\n  0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00,  // range...\n  0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72,  // .referer\n  0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72,  // ....retr\n  0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00,  // y-after.\n  0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65,  // ...serve\n  0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00,  // r....te.\n  0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c,  // ...trail\n  0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72,  // er....tr\n  0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65,  // ansfer-e\n  0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00,  // ncoding.\n  0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61,  // ...upgra\n  0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73,  // de....us\n  0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74,  // er-agent\n  0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79,  // ....vary\n  0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00,  // ....via.\n  0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69,  // ...warni\n  0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77,  // ng....ww\n  0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,  // w-authen\n  0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00,  // ticate..\n  0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,  // ..method\n  0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00,  // ....get.\n  0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,  // ...statu\n  0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30,  // s....200\n  0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76,  // .OK....v\n  0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,  // ersion..\n  0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,  // ..HTTP.1\n  0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72,  // .1....ur\n  0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62,  // l....pub\n  0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73,  // lic....s\n  0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69,  // et-cooki\n  0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65,  // e....kee\n  0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00,  // p-alive.\n  0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69,  // ...origi\n  0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32,  // n1001012\n  0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35,  // 01202205\n  0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30,  // 20630030\n  0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33,  // 23033043\n  0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37,  // 05306307\n  0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30,  // 40240540\n  0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34,  // 64074084\n  0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31,  // 09410411\n  0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31,  // 41241341\n  0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34,  // 44154164\n  0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34,  // 17502504\n  0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e,  // 505203.N\n  0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f,  // on-Autho\n  0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,  // ritative\n  0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61,  // .Informa\n  0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20,  // tion204.\n  0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65,  // No.Conte\n  0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f,  // nt301.Mo\n  0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d,  // ved.Perm\n  0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34,  // anently4\n  0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52,  // 00.Bad.R\n  0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30,  // equest40\n  0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68,  // 1.Unauth\n  0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30,  // orized40\n  0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64,  // 3.Forbid\n  0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e,  // den404.N\n  0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64,  // ot.Found\n  0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65,  // 500.Inte\n  0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72,  // rnal.Ser\n  0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f,  // ver.Erro\n  0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74,  // r501.Not\n  0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65,  // .Impleme\n  0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20,  // nted503.\n  0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,  // Service.\n  0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61,  // Unavaila\n  0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46,  // bleJan.F\n  0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41,  // eb.Mar.A\n  0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a,  // pr.May.J\n  0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41,  // un.Jul.A\n  0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20,  // ug.Sept.\n  0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20,  // Oct.Nov.\n  0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30,  // Dec.00.0\n  0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e,  // 0.00.Mon\n  0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57,  // ..Tue..W\n  0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c,  // ed..Thu.\n  0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61,  // .Fri..Sa\n  0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20,  // t..Sun..\n  0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b,  // GMTchunk\n  0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f,  // ed.text.\n  0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61,  // html.ima\n  0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69,  // ge.png.i\n  0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67,  // mage.jpg\n  0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67,  // .image.g\n  0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,  // if.appli\n  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,  // cation.x\n  0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,  // ml.appli\n  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,  // cation.x\n  0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c,  // html.xml\n  0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c,  // .text.pl\n  0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74,  // ain.text\n  0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72,  // .javascr\n  0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c,  // ipt.publ\n  0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74,  // icprivat\n  0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65,  // emax-age\n  0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65,  // .gzip.de\n  0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64,  // flate.sd\n  0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,  // chcharse\n  0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63,  // t.utf-8c\n  0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69,  // harset.i\n  0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d,  // so-8859-\n  0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a,  // 1.utf-..\n  0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e         // .enq.0.\n]);\n\ndictionary[3.1] = dictionary[3];\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/constants.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar base = transport.protocol.base;\n\nexports.FRAME_HEADER_SIZE = 8;\n\nexports.PING_OPAQUE_SIZE = 4;\n\nexports.MAX_CONCURRENT_STREAMS = Infinity;\nexports.DEFAULT_MAX_HEADER_LIST_SIZE = Infinity;\n\nexports.DEFAULT_WEIGHT = 16;\n\nexports.frameType = {\n  SYN_STREAM: 1,\n  SYN_REPLY: 2,\n  RST_STREAM: 3,\n  SETTINGS: 4,\n  PING: 6,\n  GOAWAY: 7,\n  HEADERS: 8,\n  WINDOW_UPDATE: 9,\n\n  // Custom\n  X_FORWARDED_FOR: 0xf000\n};\n\nexports.flags = {\n  FLAG_FIN: 0x01,\n  FLAG_COMPRESSED: 0x02,\n  FLAG_UNIDIRECTIONAL: 0x02\n};\n\nexports.error = {\n  PROTOCOL_ERROR: 1,\n  INVALID_STREAM: 2,\n  REFUSED_STREAM: 3,\n  UNSUPPORTED_VERSION: 4,\n  CANCEL: 5,\n  INTERNAL_ERROR: 6,\n  FLOW_CONTROL_ERROR: 7,\n  STREAM_IN_USE: 8,\n  // STREAM_ALREADY_CLOSED: 9\n  STREAM_CLOSED: 9,\n  INVALID_CREDENTIALS: 10,\n  FRAME_TOO_LARGE: 11\n};\nexports.errorByCode = base.utils.reverse(exports.error);\n\nexports.settings = {\n  FLAG_SETTINGS_PERSIST_VALUE: 1,\n  FLAG_SETTINGS_PERSISTED: 2,\n\n  SETTINGS_UPLOAD_BANDWIDTH: 1,\n  SETTINGS_DOWNLOAD_BANDWIDTH: 2,\n  SETTINGS_ROUND_TRIP_TIME: 3,\n  SETTINGS_MAX_CONCURRENT_STREAMS: 4,\n  SETTINGS_CURRENT_CWND: 5,\n  SETTINGS_DOWNLOAD_RETRANS_RATE: 6,\n  SETTINGS_INITIAL_WINDOW_SIZE: 7,\n  SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE: 8\n};\n\nexports.settingsIndex = [\n  null,\n\n  'upload_bandwidth',\n  'download_bandwidth',\n  'round_trip_time',\n  'max_concurrent_streams',\n  'current_cwnd',\n  'download_retrans_rate',\n  'initial_window_size',\n  'client_certificate_vector_size'\n];\n\nexports.DEFAULT_WINDOW = 64 * 1024;\nexports.MAX_INITIAL_WINDOW_SIZE = 2147483647;\n\nexports.goaway = {\n  OK: 0,\n  PROTOCOL_ERROR: 1,\n  INTERNAL_ERROR: 2\n};\nexports.goawayByCode = base.utils.reverse(exports.goaway);\n\nexports.statusReason = {\n  100 : 'Continue',\n  101 : 'Switching Protocols',\n  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n  200 : 'OK',\n  201 : 'Created',\n  202 : 'Accepted',\n  203 : 'Non-Authoritative Information',\n  204 : 'No Content',\n  205 : 'Reset Content',\n  206 : 'Partial Content',\n  207 : 'Multi-Status',               // RFC 4918\n  300 : 'Multiple Choices',\n  301 : 'Moved Permanently',\n  302 : 'Moved Temporarily',\n  303 : 'See Other',\n  304 : 'Not Modified',\n  305 : 'Use Proxy',\n  307 : 'Temporary Redirect',\n  308 : 'Permanent Redirect',         // RFC 7238\n  400 : 'Bad Request',\n  401 : 'Unauthorized',\n  402 : 'Payment Required',\n  403 : 'Forbidden',\n  404 : 'Not Found',\n  405 : 'Method Not Allowed',\n  406 : 'Not Acceptable',\n  407 : 'Proxy Authentication Required',\n  408 : 'Request Time-out',\n  409 : 'Conflict',\n  410 : 'Gone',\n  411 : 'Length Required',\n  412 : 'Precondition Failed',\n  413 : 'Request Entity Too Large',\n  414 : 'Request-URI Too Large',\n  415 : 'Unsupported Media Type',\n  416 : 'Requested Range Not Satisfiable',\n  417 : 'Expectation Failed',\n  418 : 'I\\'m a teapot',              // RFC 2324\n  422 : 'Unprocessable Entity',       // RFC 4918\n  423 : 'Locked',                     // RFC 4918\n  424 : 'Failed Dependency',          // RFC 4918\n  425 : 'Unordered Collection',       // RFC 4918\n  426 : 'Upgrade Required',           // RFC 2817\n  428 : 'Precondition Required',      // RFC 6585\n  429 : 'Too Many Requests',          // RFC 6585\n  431 : 'Request Header Fields Too Large',// RFC 6585\n  500 : 'Internal Server Error',\n  501 : 'Not Implemented',\n  502 : 'Bad Gateway',\n  503 : 'Service Unavailable',\n  504 : 'Gateway Time-out',\n  505 : 'HTTP Version Not Supported',\n  506 : 'Variant Also Negotiates',    // RFC 2295\n  507 : 'Insufficient Storage',       // RFC 4918\n  509 : 'Bandwidth Limit Exceeded',\n  510 : 'Not Extended',               // RFC 2774\n  511 : 'Network Authentication Required' // RFC 6585\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/parser.js":"'use strict';\n\nvar parser = exports;\n\nvar transport = require('../../../spdy-transport');\nvar base = transport.protocol.base;\nvar utils = base.utils;\nvar constants = require('./constants');\n\nvar assert = require('assert');\nvar util = require('util');\nvar OffsetBuffer = require('obuf');\n\nfunction Parser(options) {\n  base.Parser.call(this, options);\n\n  this.isServer = options.isServer;\n  this.waiting = constants.FRAME_HEADER_SIZE;\n  this.state = 'frame-head';\n  this.pendingHeader = null;\n}\nutil.inherits(Parser, base.Parser);\n\nparser.create = function create(options) {\n  return new Parser(options);\n};\n\nParser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {\n  // http2-only\n};\n\nParser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {\n  // http2-only\n};\n\n// Only for testing\nParser.prototype.skipPreface = function skipPreface() {\n};\n\nParser.prototype.execute = function execute(buffer, callback) {\n  if (this.state === 'frame-head')\n    return this.onFrameHead(buffer, callback);\n\n  assert(this.state === 'frame-body' && this.pendingHeader !== null);\n\n  var self = this;\n  var header = this.pendingHeader;\n  this.pendingHeader = null;\n\n  this.onFrameBody(header, buffer, function(err, frame) {\n    if (err)\n      return callback(err);\n\n    self.state = 'frame-head';\n    self.waiting = constants.FRAME_HEADER_SIZE;\n    self.partial = false;\n    callback(null, frame);\n  });\n};\n\nParser.prototype.executePartial = function executePartial(buffer, callback) {\n  var header = this.pendingHeader;\n\n  if (this.window)\n    this.window.recv.update(-buffer.size);\n\n  // DATA frame\n  callback(null, {\n    type: 'DATA',\n    id: header.id,\n\n    // Partial DATA can't be FIN\n    fin: false,\n    data: buffer.take(buffer.size)\n  });\n};\n\nParser.prototype.onFrameHead = function onFrameHead(buffer, callback) {\n  var header = {\n    control: (buffer.peekUInt8() & 0x80) === 0x80 ? true : false,\n    version: null,\n    type: null,\n    id: null,\n    flags: null,\n    length: null\n  };\n\n  if (header.control) {\n    header.version = buffer.readUInt16BE() & 0x7fff;\n    header.type = buffer.readUInt16BE();\n  } else {\n    header.id = buffer.readUInt32BE(0) & 0x7fffffff;\n  }\n  header.flags = buffer.readUInt8();\n  header.length = buffer.readUInt24BE();\n\n  if (this.version === null && header.control) {\n    // TODO(indutny): do ProtocolError here and in the rest of errors\n    if (header.version !== 2 && header.version !== 3)\n      return callback(new Error('Unsupported SPDY version: ' + header.version));\n    this.setVersion(header.version);\n  }\n\n  this.state = 'frame-body';\n  this.waiting = header.length;\n  this.pendingHeader = header;\n  this.partial = !header.control;\n\n  callback(null, null);\n};\n\nParser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {\n  // Data frame\n  if (!header.control) {\n    // Count received bytes\n    if (this.window)\n      this.window.recv.update(-buffer.size);\n\n    // No support for compressed DATA\n    if ((header.flags & constants.flags.FLAG_COMPRESSED) !== 0)\n      return callback(new Error('DATA compression not supported'));\n\n    if (header.id === 0) {\n      return callback(this.error(constants.error.PROTOCOL_ERROR,\n                                 'Invalid stream id for DATA'));\n    }\n\n    return callback(null, {\n      type: 'DATA',\n      id: header.id,\n      fin: (header.flags & constants.flags.FLAG_FIN) !== 0,\n      data: buffer.take(buffer.size)\n    });\n  }\n\n  // SYN_STREAM or SYN_REPLY\n  if (header.type === 0x01 || header.type === 0x02)\n    this.onSynHeadFrame(header.type, header.flags, buffer, callback);\n  // RST_STREAM\n  else if (header.type === 0x03)\n    this.onRSTFrame(buffer, callback);\n  // SETTINGS\n  else if (header.type === 0x04)\n    this.onSettingsFrame(buffer, callback);\n  else if (header.type === 0x05)\n    callback(null, { type: 'NOOP' });\n  // PING\n  else if (header.type === 0x06)\n    this.onPingFrame(buffer, callback);\n  // GOAWAY\n  else if (header.type === 0x07)\n    this.onGoawayFrame(buffer, callback);\n  // HEADERS\n  else if (header.type === 0x08)\n    this.onHeaderFrames(buffer, callback);\n  // WINDOW_UPDATE\n  else if (header.type === 0x09)\n    this.onWindowUpdateFrame(buffer, callback);\n  // X-FORWARDED\n  else if (header.type === 0xf000)\n    this.onXForwardedFrame(buffer, callback);\n  else\n    callback(null, { type: 'unknown: ' + header.type });\n};\n\nParser.prototype._filterHeader = function _filterHeader(headers, name) {\n  var res = {};\n  var keys = Object.keys(headers);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== name)\n      res[key] = headers[key];\n  }\n\n  return res;\n};\n\nParser.prototype.onSynHeadFrame = function onSynHeadFrame(type,\n                                                          flags,\n                                                          body,\n                                                          callback) {\n  var self = this;\n  var stream = type === 0x01;\n  var offset = stream ? 10 : this.version === 2 ? 6 : 4;\n\n  if (!body.has(offset))\n    return callback(new Error('SynHead OOB'));\n\n  var head = body.clone(offset);\n  body.skip(offset);\n  this.parseKVs(body, function(err, headers) {\n    if (err)\n      return callback(err);\n\n    if (stream &&\n        (!headers[':method'] || !headers[':path'])) {\n      return callback(new Error('Missing `:method` and/or `:path` header'));\n    }\n\n    var id = head.readUInt32BE() & 0x7fffffff;\n\n    if (id === 0) {\n      return callback(self.error(constants.error.PROTOCOL_ERROR,\n                                 'Invalid stream id for HEADERS'));\n    }\n\n    var associated = stream ? head.readUInt32BE() & 0x7fffffff : 0;\n    var priority = stream ? head.readUInt8() >> 5 :\n                            utils.weightToPriority(constants.DEFAULT_WEIGHT);\n    var fin = (flags & constants.flags.FLAG_FIN) !== 0;\n    var unidir = (flags & constants.flags.FLAG_UNIDIRECTIONAL) !== 0;\n    var path = headers[':path'];\n\n    var isPush = stream && associated !== 0;\n\n    var weight = utils.priorityToWeight(priority);\n    var priorityInfo = {\n      weight: weight,\n      exclusive: false,\n      parent: 0\n    };\n\n    if (!isPush) {\n      callback(null, {\n        type: 'HEADERS',\n        id: id,\n        priority: priorityInfo,\n        fin: fin,\n        writable: !unidir,\n        headers: headers,\n        path: path\n      });\n      return;\n    }\n\n    if (stream && !headers[':status'])\n      return callback(new Error('Missing `:status` header'));\n\n    var filteredHeaders = self._filterHeader(headers, ':status');\n\n    callback(null, [ {\n      type: 'PUSH_PROMISE',\n      id: associated,\n      fin: false,\n      promisedId: id,\n      headers: filteredHeaders,\n      path: path\n    }, {\n      type: 'HEADERS',\n      id: id,\n      fin: fin,\n      priority: priorityInfo,\n      writable: true,\n      path: undefined,\n      headers: {\n        ':status': headers[':status']\n      }\n    }]);\n  });\n};\n\nParser.prototype.onHeaderFrames = function onHeaderFrames(body, callback) {\n  var offset = this.version === 2 ? 6 : 4;\n  if (!body.has(offset))\n    return callback(new Error('HEADERS OOB'));\n\n  var streamId = body.readUInt32BE() & 0x7fffffff;\n  if (this.version === 2)\n    body.skip(2);\n\n  this.parseKVs(body, function(err, headers) {\n    if (err)\n      return callback(err);\n\n    callback(null, {\n      type: 'HEADERS',\n      priority: {\n        parent: 0,\n        exclusive: false,\n        weight: constants.DEFAULT_WEIGHT\n      },\n      id: streamId,\n      fin: false,\n      writable: true,\n      path: undefined,\n      headers: headers\n    });\n  });\n};\n\nParser.prototype.parseKVs = function parseKVs(buffer, callback) {\n  var self = this;\n\n  this.decompress.write(buffer.toChunks(), function(err, chunks) {\n    if (err)\n      return callback(err);\n\n    var buffer = new OffsetBuffer();\n    for (var i = 0; i < chunks.length; i++)\n      buffer.push(chunks[i]);\n\n    var size = self.version === 2 ? 2 : 4;\n    if (!buffer.has(size))\n      return callback(new Error('KV OOB'));\n\n    var count = self.version === 2 ? buffer.readUInt16BE() :\n                                     buffer.readUInt32BE();\n    var headers = {};\n\n    function readString() {\n      if (!buffer.has(size))\n        return null;\n      var len = self.version === 2 ? buffer.readUInt16BE() :\n                                     buffer.readUInt32BE();\n\n      if (!buffer.has(len))\n        return null;\n\n      var value = buffer.take(len);\n      return value.toString();\n    }\n\n    while (count > 0) {\n      var key = readString();\n      var value = readString();\n\n      if (key === null || value === null)\n        return callback(new Error('Headers OOB'));\n\n      if (self.version < 3) {\n        var isInternal = /^(method|version|url|host|scheme|status)$/.test(key);\n        if (key === 'url')\n          key = 'path';\n        if (isInternal)\n          key = ':' + key;\n      }\n\n      // Compatibility with HTTP2\n      if (key === ':status')\n        value = value.split(/ /g, 2)[0];\n\n      count--;\n      if (key === ':host')\n        key = ':authority';\n\n      // Skip version, not present in HTTP2\n      if (key === ':version')\n        continue;\n\n      value = value.split(/\\0/g);\n      for (var i = 0; i < value.length; i++)\n        utils.addHeaderLine(key, value[i], headers);\n    }\n\n    callback(null, headers);\n  });\n};\n\nParser.prototype.onRSTFrame = function onRSTFrame(body, callback) {\n  if (!body.has(8))\n    return callback(new Error('RST OOB'));\n\n  var frame = {\n    type: 'RST',\n    id: body.readUInt32BE() & 0x7fffffff,\n    code: constants.errorByCode[body.readUInt32BE()],\n  };\n\n  if (frame.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for RST'));\n  }\n\n  if (body.size !== 0)\n    frame.extra = body.take(body.size);\n  callback(null, frame);\n};\n\nParser.prototype.onSettingsFrame = function onSettingsFrame(body, callback) {\n  if (!body.has(4))\n    return callback(new Error('SETTINGS OOB'));\n\n  var settings = {},\n      number = body.readUInt32BE(),\n      idMap = {\n        1: 'upload_bandwidth',\n        2: 'download_bandwidth',\n        3: 'round_trip_time',\n        4: 'max_concurrent_streams',\n        5: 'current_cwnd',\n        6: 'download_retrans_rate',\n        7: 'initial_window_size',\n        8: 'client_certificate_vector_size'\n      };\n\n  if (!body.has(number * 8))\n    return callback(new Error('SETTINGS OOB#2'));\n\n  for (var i = 0; i < number; i++) {\n    var id = this.version === 2 ? body.readUInt32LE() :\n                                   body.readUInt32BE();\n    var flags = (id >> 24) & 0xff;\n    id = id & 0xffffff;\n\n    // Skip persisted settings\n    if (flags & 0x2)\n      continue;\n\n    var name = idMap[id];\n\n    settings[name] = body.readUInt32BE();\n  }\n\n  callback(null, {\n    type: 'SETTINGS',\n    settings: settings\n  });\n};\n\nParser.prototype.onPingFrame = function onPingFrame(body, callback) {\n  if (!body.has(4))\n    return callback(new Error('PING OOB'));\n\n  var isServer = this.isServer;\n  var opaque = body.clone(body.size).take(body.size);\n  var id = body.readUInt32BE();\n  var ack = isServer ? (id % 2 === 0) : (id % 2 === 1);\n\n  callback(null, { type: 'PING', opaque: opaque, ack: ack });\n};\n\nParser.prototype.onGoawayFrame = function onGoawayFrame(body, callback) {\n  if (!body.has(8))\n    return callback(new Error('GOAWAY OOB'));\n\n  callback(null, {\n    type: 'GOAWAY',\n    lastId: body.readUInt32BE() & 0x7fffffff,\n    code: constants.goawayByCode[body.readUInt32BE()]\n  });\n};\n\nParser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(body,\n                                                                    callback) {\n  if (!body.has(8))\n    return callback(new Error('WINDOW_UPDATE OOB'));\n\n  callback(null, {\n    type: 'WINDOW_UPDATE',\n    id: body.readUInt32BE() & 0x7fffffff,\n    delta: body.readInt32BE()\n  });\n};\n\nParser.prototype.onXForwardedFrame = function onXForwardedFrame(body,\n                                                                callback) {\n  if (!body.has(4))\n    return callback(new Error('X_FORWARDED OOB'));\n\n  var len = body.readUInt32BE();\n  if (!body.has(len))\n    return callback(new Error('X_FORWARDED host length OOB'));\n\n  callback(null, {\n    type: 'X_FORWARDED_FOR',\n    host: body.take(len).toString()\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/framer.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar constants = require('./').constants;\nvar base = transport.protocol.base;\nvar utils = base.utils;\n\nvar assert = require('assert');\nvar util = require('util');\nvar Buffer = require('buffer').Buffer;\nvar WriteBuffer = require('wbuf');\n\nvar debug = require('debug')('spdy:framer');\n\nfunction Framer(options) {\n  base.Framer.call(this, options);\n}\nutil.inherits(Framer, base.Framer);\nmodule.exports = Framer;\n\nFramer.create = function create(options) {\n  return new Framer(options);\n};\n\nFramer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {\n  // http2-only\n};\n\nFramer.prototype.headersToDict = function headersToDict(headers,\n                                                        preprocess,\n                                                        callback) {\n  function stringify(value) {\n    if (value !== undefined) {\n      if (Array.isArray(value)) {\n        return value.join('\\x00');\n      } else if (typeof value === 'string') {\n        return value;\n      } else {\n        return value.toString();\n      }\n    } else {\n      return '';\n    }\n  }\n\n  // Lower case of all headers keys\n  var loweredHeaders = {};\n  Object.keys(headers || {}).map(function(key) {\n    loweredHeaders[key.toLowerCase()] = headers[key];\n  });\n\n  // Allow outer code to add custom headers or remove something\n  if (preprocess)\n    preprocess(loweredHeaders);\n\n  // Transform object into kv pairs\n  var size = this.version === 2 ? 2 : 4;\n  var len = size;\n  var pairs = Object.keys(loweredHeaders).filter(function(key) {\n    var lkey = key.toLowerCase();\n\n    // Will be in `:host`\n    if (lkey === 'host' && this.version >= 3)\n      return false;\n\n    return lkey !== 'connection' && lkey !== 'keep-alive' &&\n           lkey !== 'proxy-connection' && lkey !== 'transfer-encoding';\n  }, this).map(function(key) {\n    var klen = Buffer.byteLength(key),\n        value = stringify(loweredHeaders[key]),\n        vlen = Buffer.byteLength(value);\n\n    len += size * 2 + klen + vlen;\n    return [klen, key, vlen, value];\n  });\n\n  var block = new WriteBuffer();\n  block.reserve(len);\n\n  if (this.version === 2)\n    block.writeUInt16BE(pairs.length);\n  else\n    block.writeUInt32BE(pairs.length);\n\n  pairs.forEach(function(pair) {\n    // Write key length\n    if (this.version === 2)\n      block.writeUInt16BE(pair[0]);\n    else\n      block.writeUInt32BE(pair[0]);\n\n    // Write key\n    block.write(pair[1]);\n\n    // Write value length\n    if (this.version === 2)\n      block.writeUInt16BE(pair[2]);\n    else\n      block.writeUInt32BE(pair[2]);\n    // Write value\n    block.write(pair[3]);\n  }, this);\n\n  assert(this.compress !== null, 'Framer version not initialized');\n  this.compress.write(block.render(), callback);\n};\n\nFramer.prototype._frame = function _frame(frame, body, callback) {\n  if (!this.version) {\n    this.on('version', function() {\n      this._frame(frame, body, callback);\n    });\n    return;\n  }\n\n  debug('id=%d type=%s', frame.id, frame.type);\n\n  var buffer = new WriteBuffer();\n\n  buffer.writeUInt16BE(0x8000 | this.version);\n  buffer.writeUInt16BE(constants.frameType[frame.type]);\n  buffer.writeUInt8(frame.flags);\n  var len = buffer.skip(3);\n\n  var self = this;\n  body(buffer);\n\n  var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;\n  len.writeUInt24BE(frameSize);\n\n  var chunks = buffer.render();\n  var toWrite = {\n    stream: frame.id,\n    priority: false,\n    chunks: chunks,\n    callback: callback\n  };\n\n  this._resetTimeout();\n  this.schedule(toWrite);\n\n  return chunks;\n};\n\nFramer.prototype._synFrame = function _synFrame(frame, callback) {\n  var self = this;\n\n  if (!frame.path)\n    throw new Error('`path` is required frame argument');\n\n  function preprocess(headers) {\n    var method = frame.method || base.constants.DEFAULT_METHOD;\n    var version = frame.version || 'HTTP/1.1';\n    var scheme = frame.scheme || 'https';\n    var host = frame.host ||\n               frame.headers && frame.headers.host ||\n               base.constants.DEFAULT_HOST;\n\n    if (self.version === 2) {\n      headers.method = method;\n      headers.version = version;\n      headers.url = frame.path;\n      headers.scheme = scheme;\n      headers.host = host;\n      if (frame.status)\n        headers.status = frame.status;\n    } else {\n      headers[':method'] = method;\n      headers[':version'] = version;\n      headers[':path'] = frame.path;\n      headers[':scheme'] = scheme;\n      headers[':host'] = host;\n      if (frame.status)\n        headers[':status'] = frame.status;\n    }\n  }\n\n  this.headersToDict(frame.headers, preprocess, function(err, chunks) {\n    if (err) {\n      if (callback)\n        return callback(err);\n      else\n        return self.emit('error', err);\n    }\n\n    self._frame({\n      type: 'SYN_STREAM',\n      id: frame.id,\n      flags: frame.fin ? constants.flags.FLAG_FIN : 0\n    }, function(buf) {\n      buf.reserve(10);\n\n      buf.writeUInt32BE(frame.id & 0x7fffffff);\n      buf.writeUInt32BE(frame.associated & 0x7fffffff);\n\n      var weight = frame.priority && frame.priority.weight ||\n                   constants.DEFAULT_WEIGHT;\n\n      // We only have 3 bits for priority in SPDY, try to fit it into this\n      var priority = utils.weightToPriority(weight);\n      buf.writeUInt8(priority << 5);\n\n      // CREDENTIALS slot\n      buf.writeUInt8(0);\n\n      for (var i = 0; i < chunks.length; i++)\n        buf.copyFrom(chunks[i]);\n    }, callback);\n  });\n};\n\nFramer.prototype.requestFrame = function requestFrame(frame, callback) {\n  this._synFrame({\n    id: frame.id,\n    fin: frame.fin,\n    associated: 0,\n    method: frame.method,\n    version: frame.version,\n    scheme: frame.scheme,\n    host: frame.host,\n    path: frame.path,\n    priority: frame.priority,\n    headers: frame.headers\n  }, callback);\n};\n\nFramer.prototype.responseFrame = function responseFrame(frame, callback) {\n  var self = this;\n\n  var reason = frame.reason;\n  if (!reason)\n    reason = constants.statusReason[frame.status];\n\n  function preprocess(headers) {\n    if (self.version === 2) {\n      headers.status = frame.status + ' ' + reason;\n      headers.version = 'HTTP/1.1';\n    } else {\n      headers[':status'] = frame.status + ' ' + reason;\n      headers[':version'] = 'HTTP/1.1';\n    }\n  }\n\n  this.headersToDict(frame.headers, preprocess, function(err, chunks) {\n    if (err) {\n      if (callback)\n        return callback(err);\n      else\n        return self.emit('error', err);\n    }\n\n    self._frame({\n      type: 'SYN_REPLY',\n      id: frame.id,\n      flags: 0\n    }, function(buf) {\n      buf.reserve(self.version === 2 ? 6 : 4);\n\n      buf.writeUInt32BE(frame.id & 0x7fffffff);\n\n      // Unused data\n      if (self.version === 2)\n        buf.writeUInt16BE(0);\n\n      for (var i = 0; i < chunks.length; i++)\n        buf.copyFrom(chunks[i]);\n    }, callback);\n  });\n};\n\n\nFramer.prototype.pushFrame = function pushFrame(frame, callback) {\n  var self = this;\n\n  this._checkPush(function(err) {\n    if (err)\n      return callback(err);\n\n    self._synFrame({\n      id: frame.promisedId,\n      associated: frame.id,\n      method: frame.method,\n      status: frame.status || 200,\n      version: frame.version,\n      scheme: frame.scheme,\n      host: frame.host,\n      path: frame.path,\n      priority: frame.priority,\n\n      // Merge everything together, there is no difference in SPDY protocol\n      headers: util._extend(util._extend({}, frame.headers), frame.response)\n    }, callback);\n  });\n};\n\nFramer.prototype.headersFrame = function headersFrame(frame, callback) {\n  var self = this;\n\n  this.headersToDict(frame.headers, null, function(err, chunks) {\n    if (err) {\n      if (callback)\n        return callback(err);\n      else\n        return self.emit('error', err);\n    }\n\n    self._frame({\n      type: 'HEADERS',\n      id: frame.id,\n      priority: false,\n      flags: 0\n    }, function(buf) {\n      buf.reserve(4 + (self.version === 2 ? 2 : 0));\n      buf.writeUInt32BE(frame.id & 0x7fffffff);\n\n      // Unused data\n      if (self.version === 2)\n        buf.writeUInt16BE(0);\n\n      for (var i = 0; i < chunks.length; i++)\n        buf.copyFrom(chunks[i]);\n    }, callback);\n  });\n};\n\nFramer.prototype.dataFrame = function dataFrame(frame, callback) {\n  if (!this.version) {\n    return this.on('version', function() {\n      this.dataFrame(frame, callback);\n    });\n  }\n\n  debug('id=%d type=DATA', frame.id);\n\n  var buffer = new WriteBuffer();\n  buffer.reserve(8 + frame.data.length);\n\n  buffer.writeUInt32BE(frame.id & 0x7fffffff);\n  buffer.writeUInt8(frame.fin ? 0x01 : 0x0);\n  buffer.writeUInt24BE(frame.data.length);\n  buffer.copyFrom(frame.data);\n\n  var chunks = buffer.render();\n  var toWrite = {\n    stream: frame.id,\n    priority: frame.priority,\n    chunks: chunks,\n    callback: callback\n  };\n\n  var self = this;\n  this._resetTimeout();\n\n  var bypass = this.version < 3.1;\n  this.window.send.update(-frame.data.length, bypass ? undefined : function() {\n    self._resetTimeout();\n    self.schedule(toWrite);\n  });\n\n  if (bypass) {\n    this._resetTimeout();\n    this.schedule(toWrite);\n  }\n};\n\nFramer.prototype.pingFrame = function pingFrame(frame, callback) {\n  this._frame({\n    type: 'PING',\n    id: 0,\n    flags: 0\n  }, function(buf, callback) {\n    buf.reserve(4);\n\n    var opaque = frame.opaque;\n    buf.writeUInt32BE(opaque.readUInt32BE(opaque.length - 4, true));\n  }, callback);\n};\n\nFramer.prototype.rstFrame = function rstFrame(frame, callback) {\n  var self = this;\n\n  this._frame({\n    type: 'RST_STREAM',\n    id: frame.id,\n    flags: 0\n  }, function(buf) {\n    buf.reserve(8);\n\n    // Stream ID\n    buf.writeUInt32BE(frame.id & 0x7fffffff);\n    // Status Code\n    buf.writeUInt32BE(constants.error[frame.code]);\n\n    // Extra debugging information\n    if (frame.extra)\n      buf.write(frame.extra);\n  }, callback);\n};\n\nFramer.prototype.prefaceFrame = function prefaceFrame() {\n};\n\nFramer.prototype.settingsFrame = function settingsFrame(options, callback) {\n  var self = this;\n\n  var key = this.version + '/' + JSON.stringify(options);\n\n  var settings = Framer.settingsCache[key];\n  if (settings) {\n    debug('cached settings');\n    this._resetTimeout();\n    this.schedule({\n      stream: 0,\n      priority: false,\n      chunks: settings,\n      callback: callback\n    });\n    return;\n  }\n\n  var params = [];\n  for (var i = 0; i < constants.settingsIndex.length; i++) {\n    var name = constants.settingsIndex[i];\n    if (!name)\n      continue;\n\n    // value: Infinity\n    if (!isFinite(options[name]))\n      continue;\n\n    if (options[name] !== undefined)\n      params.push({ key: i, value: options[name] });\n  }\n\n  var frame = this._frame({\n    type: 'SETTINGS',\n    id: 0,\n    flags: 0\n  }, function(buf) {\n    buf.reserve(4 + 8 * params.length);\n\n    // Count of entries\n    buf.writeUInt32BE(params.length);\n\n    params.forEach(function(param) {\n      var flag = constants.settings.FLAG_SETTINGS_PERSIST_VALUE << 24;\n\n      if (self.version === 2)\n        buf.writeUInt32LE(flag | param.key);\n      else\n        buf.writeUInt32BE(flag | param.key);\n      buf.writeUInt32BE(param.value & 0x7fffffff);\n    });\n  }, callback);\n\n  Framer.settingsCache[key] = frame;\n};\nFramer.settingsCache = {};\n\nFramer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {\n  if (callback)\n    process.nextTick(callback);\n};\n\nFramer.prototype.windowUpdateFrame = function windowUpdateFrame(frame,\n                                                                callback) {\n  this._frame({\n    type: 'WINDOW_UPDATE',\n    id: frame.id,\n    flags: 0\n  }, function(buf) {\n    buf.reserve(8);\n\n    // ID\n    buf.writeUInt32BE(frame.id & 0x7fffffff);\n\n    // Delta\n    buf.writeInt32BE(frame.delta);\n  }, callback);\n};\n\nFramer.prototype.goawayFrame = function goawayFrame(frame, callback) {\n  this._frame({\n    type: 'GOAWAY',\n    id: 0,\n    flags: 0\n  }, function(buf) {\n    buf.reserve(8);\n\n    // Last-good-stream-ID\n    buf.writeUInt32BE(frame.lastId & 0x7fffffff);\n    // Status\n    buf.writeUInt32BE(constants.goaway[frame.code]);\n  }, callback);\n};\n\nFramer.prototype.priorityFrame = function priorityFrame(frame, callback) {\n  // No such thing in SPDY\n  if (callback)\n    process.nextTick(callback);\n};\n\nFramer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {\n  this._frame({\n    type: 'X_FORWARDED_FOR',\n    id: 0,\n    flags: 0\n  }, function(buf) {\n    buf.writeUInt32BE(Buffer.byteLength(frame.host));\n    buf.write(frame.host);\n  }, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/spdy/zlib-pool.js":"'use strict';\n\nvar zlibpool = exports;\nvar zlib = require('zlib');\n\nvar transport = require('../../../spdy-transport');\n\n// TODO(indutny): think about it, why has it always been Z_SYNC_FLUSH here.\n// It should be possible to manually flush stuff after the write instead\nfunction createDeflate(version, compression) {\n  var deflate = zlib.createDeflate({\n    dictionary: transport.protocol.spdy.dictionary[version],\n    flush: zlib.Z_SYNC_FLUSH,\n    windowBits: 11,\n    level: compression ? zlib.Z_DEFAULT_COMPRESSION : zlib.Z_NO_COMPRESSION\n  });\n\n  // For node.js v0.8\n  deflate._flush = zlib.Z_SYNC_FLUSH;\n\n  return deflate;\n}\n\nfunction createInflate(version) {\n  var inflate = zlib.createInflate({\n    dictionary: transport.protocol.spdy.dictionary[version],\n    flush: zlib.Z_SYNC_FLUSH,\n    windowBits: 0\n  });\n\n  // For node.js v0.8\n  inflate._flush = zlib.Z_SYNC_FLUSH;\n\n  return inflate;\n}\n\nfunction Pool(compression) {\n  this.compression = compression;\n  this.pool = {\n    2: [],\n    3: [],\n    3.1: []\n  };\n}\n\nzlibpool.create = function create(compression) {\n  return new Pool(compression);\n};\n\nPool.prototype.get = function get(version) {\n  if (this.pool[version].length > 0) {\n    return this.pool[version].pop();\n  } else {\n    var id = version;\n\n    return {\n      version: version,\n      compress: createDeflate(id, this.compression),\n      decompress: createInflate(id)\n    };\n  }\n};\n\nPool.prototype.put = function put(pair) {\n  this.pool[pair.version].push(pair);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/index.js":"'use strict';\n\nexports.name = 'h2';\n\nexports.constants = require('./constants');\nexports.parser = require('./parser');\nexports.framer = require('./framer');\nexports.compressionPool = require('./hpack-pool');\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/constants.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar base = transport.protocol.base;\n\nvar util = require('util');\nvar Buffer = require('buffer').Buffer;\n\nexports.PREFACE_SIZE = 24;\nexports.PREFACE = 'PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n';\nexports.PREFACE_BUFFER = new Buffer(exports.PREFACE);\n\nexports.PING_OPAQUE_SIZE = 8;\n\nexports.FRAME_HEADER_SIZE = 9;\nexports.INITIAL_MAX_FRAME_SIZE = 16384;\nexports.ABSOLUTE_MAX_FRAME_SIZE = 16777215;\nexports.HEADER_TABLE_SIZE = 4096;\nexports.DEFAULT_MAX_HEADER_LIST_SIZE = 80 * 1024;  // as in http_parser\nexports.MAX_INITIAL_WINDOW_SIZE = 2147483647;\n\nexports.DEFAULT_WEIGHT = 16;\n\nexports.MAX_CONCURRENT_STREAMS = Infinity;\n\nexports.frameType = {\n  DATA: 0,\n  HEADERS: 1,\n  PRIORITY: 2,\n  RST_STREAM: 3,\n  SETTINGS: 4,\n  PUSH_PROMISE: 5,\n  PING: 6,\n  GOAWAY: 7,\n  WINDOW_UPDATE: 8,\n  CONTINUATION: 9,\n\n  // Custom\n  X_FORWARDED_FOR: 0xde\n};\n\nexports.flags = {\n  ACK: 0x01,  // SETTINGS-only\n  END_STREAM: 0x01,\n  END_HEADERS: 0x04,\n  PADDED: 0x08,\n  PRIORITY: 0x20\n};\n\nexports.settings = {\n  SETTINGS_HEADER_TABLE_SIZE: 0x01,\n  SETTINGS_ENABLE_PUSH: 0x02,\n  SETTINGS_MAX_CONCURRENT_STREAMS: 0x03,\n  SETTINGS_INITIAL_WINDOW_SIZE: 0x04,\n  SETTINGS_MAX_FRAME_SIZE: 0x05,\n  SETTINGS_MAX_HEADER_LIST_SIZE: 0x06\n};\n\nexports.settingsIndex = [\n  null,\n  'header_table_size',\n  'enable_push',\n  'max_concurrent_streams',\n  'initial_window_size',\n  'max_frame_size',\n  'max_header_list_size'\n];\n\nexports.error = {\n  OK: 0,\n  NO_ERROR: 0,\n\n  PROTOCOL_ERROR: 1,\n  INTERNAL_ERROR: 2,\n  FLOW_CONTROL_ERROR: 3,\n  SETTINGS_TIMEOUT: 4,\n\n  STREAM_CLOSED: 5,\n  INVALID_STREAM: 5,\n\n  FRAME_SIZE_ERROR: 6,\n  REFUSED_STREAM: 7,\n  CANCEL: 8,\n  COMPRESSION_ERROR: 9,\n  CONNECT_ERROR: 10,\n  ENHANCE_YOUR_CALM: 11,\n  INADEQUATE_SECURITY: 12,\n  HTTP_1_1_REQUIRED: 13\n};\nexports.errorByCode = base.utils.reverse(exports.error);\n\nexports.DEFAULT_WINDOW = 64 * 1024 - 1;\n\nexports.goaway = exports.error;\nexports.goawayByCode = util._extend({}, exports.errorByCode);\nexports.goawayByCode[0] = 'OK';\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/parser.js":"'use strict';\n\nvar parser = exports;\n\nvar transport = require('../../../spdy-transport');\nvar base = transport.protocol.base;\nvar utils = base.utils;\nvar constants = require('./').constants;\n\nvar assert = require('assert');\nvar util = require('util');\n\nfunction Parser(options) {\n  base.Parser.call(this, options);\n\n  this.isServer = options.isServer;\n\n  this.waiting = constants.PREFACE_SIZE;\n  this.state = 'preface';\n  this.pendingHeader = null;\n\n  // Header Block queue\n  this._lastHeaderBlock = null;\n  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;\n  this.maxHeaderListSize = constants.DEFAULT_MAX_HEADER_LIST_SIZE;\n}\nutil.inherits(Parser, base.Parser);\n\nparser.create = function create(options) {\n  return new Parser(options);\n};\n\nParser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {\n  this.maxFrameSize = size;\n};\n\nParser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {\n  this.maxHeaderListSize = size;\n};\n\n// Only for testing\nParser.prototype.skipPreface = function skipPreface() {\n  // Just some number bigger than 3.1, doesn't really matter for HTTP2\n  this.setVersion(4);\n\n  // Parse frame header!\n  this.state = 'frame-head';\n  this.waiting = constants.FRAME_HEADER_SIZE;\n};\n\nParser.prototype.execute = function execute(buffer, callback) {\n  if (this.state === 'preface')\n    return this.onPreface(buffer, callback);\n\n  if (this.state === 'frame-head')\n    return this.onFrameHead(buffer, callback);\n\n  assert(this.state === 'frame-body' && this.pendingHeader !== null);\n\n  var self = this;\n  var header = this.pendingHeader;\n  this.pendingHeader = null;\n\n  this.onFrameBody(header, buffer, function(err, frame) {\n    if (err)\n      return callback(err);\n\n    self.state = 'frame-head';\n    self.partial = false;\n    self.waiting = constants.FRAME_HEADER_SIZE;\n    callback(null, frame);\n  });\n};\n\nParser.prototype.executePartial = function executePartial(buffer, callback) {\n  var header = this.pendingHeader;\n\n  assert.equal(header.flags & constants.flags.PADDED, 0);\n\n  if (this.window)\n    this.window.recv.update(-buffer.size);\n\n  callback(null, {\n    type: 'DATA',\n    id: header.id,\n\n    // Partial DATA can't be FIN\n    fin: false,\n    data: buffer.take(buffer.size)\n  });\n};\n\nParser.prototype.onPreface = function onPreface(buffer, callback) {\n  if (buffer.take(buffer.size).toString() !== constants.PREFACE) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid preface'));\n  }\n\n  this.skipPreface();\n  callback(null, null);\n};\n\nParser.prototype.onFrameHead = function onFrameHead(buffer, callback) {\n  var header = {\n    length: buffer.readUInt24BE(),\n    control: true,\n    type: buffer.readUInt8(),\n    flags: buffer.readUInt8(),\n    id: buffer.readUInt32BE() & 0x7fffffff\n  };\n\n  if (header.length > this.maxFrameSize) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'Frame length OOB'));\n  }\n\n  header.control = header.type !== constants.frameType.DATA;\n\n  this.state = 'frame-body';\n  this.pendingHeader = header;\n  this.waiting = header.length;\n  this.partial = !header.control;\n\n  // TODO(indutny): eventually support partial padded DATA\n  if (this.partial)\n    this.partial = (header.flags & constants.flags.PADDED) === 0;\n\n  callback(null, null);\n};\n\nParser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {\n  var frameType = constants.frameType;\n\n  if (header.type === frameType.DATA)\n    this.onDataFrame(header, buffer, callback);\n  else if (header.type === frameType.HEADERS)\n    this.onHeadersFrame(header, buffer, callback);\n  else if (header.type === frameType.CONTINUATION)\n    this.onContinuationFrame(header, buffer, callback);\n  else if (header.type === frameType.WINDOW_UPDATE)\n    this.onWindowUpdateFrame(header, buffer, callback);\n  else if (header.type === frameType.RST_STREAM)\n    this.onRSTFrame(header, buffer, callback);\n  else if (header.type === frameType.SETTINGS)\n    this.onSettingsFrame(header, buffer, callback);\n  else if (header.type === frameType.PUSH_PROMISE)\n    this.onPushPromiseFrame(header, buffer, callback);\n  else if (header.type === frameType.PING)\n    this.onPingFrame(header, buffer, callback);\n  else if (header.type === frameType.GOAWAY)\n    this.onGoawayFrame(header, buffer, callback);\n  else if (header.type === frameType.PRIORITY)\n    this.onPriorityFrame(header, buffer, callback);\n  else if (header.type === frameType.X_FORWARDED_FOR)\n    this.onXForwardedFrame(header, buffer, callback);\n  else\n    this.onUnknownFrame(header, buffer, callback);\n};\n\nParser.prototype.onUnknownFrame = function onUnknownFrame(header, buffer, callback) {\n  if (this._lastHeaderBlock !== null) {\n    callback(this.error(constants.error.PROTOCOL_ERROR,\n                        'Received unknown frame in the middle of a header block'));\n    return;\n  }\n  callback(null, { type: 'unknown: ' + header.type });\n};\n\nParser.prototype.unpadData = function unpadData(header, body, callback) {\n  var isPadded = (header.flags & constants.flags.PADDED) !== 0;\n\n  if (!isPadded)\n    return callback(null, body);\n\n  if (!body.has(1)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'Not enough space for padding'));\n  }\n\n  var pad = body.readUInt8();\n  if (!body.has(pad)) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid padding size'));\n  }\n\n  var contents = body.clone(body.size - pad);\n  body.skip(body.size);\n  callback(null, contents);\n};\n\nParser.prototype.onDataFrame = function onDataFrame(header, body, callback) {\n  var isEndStream = (header.flags & constants.flags.END_STREAM) !== 0;\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Received DATA frame with stream=0'));\n  }\n\n  // Count received bytes\n  if (this.window)\n    this.window.recv.update(-body.size);\n\n  this.unpadData(header, body, function(err, data) {\n    if (err)\n      return callback(err);\n\n    callback(null, {\n      type: 'DATA',\n      id: header.id,\n      fin: isEndStream,\n      data: data.take(data.size)\n    });\n  });\n};\n\nParser.prototype.initHeaderBlock = function initHeaderBlock(header,\n                                                            frame,\n                                                            block,\n                                                            callback) {\n\n  if (this._lastHeaderBlock) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Duplicate Stream ID'));\n  }\n\n  this._lastHeaderBlock = {\n    id: header.id,\n    frame: frame,\n    queue: [],\n    size: 0\n  };\n\n  this.queueHeaderBlock(header, block, callback);\n};\n\nParser.prototype.queueHeaderBlock = function queueHeaderBlock(header,\n                                                              block,\n                                                              callback) {\n  var self = this;\n  var item = this._lastHeaderBlock;\n  if (!this._lastHeaderBlock || item.id !== header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'No matching stream for continuation'));\n  }\n\n  var fin = (header.flags & constants.flags.END_HEADERS) !== 0;\n\n  var chunks = block.toChunks();\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i];\n    item.queue.push(chunk);\n    item.size += chunk.length;\n  }\n\n  if (item.size >= self.maxHeaderListSize) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Compressed header list is too large'));\n  }\n\n  if (!fin)\n    return callback(null, null);\n  this._lastHeaderBlock = null;\n\n  this.decompress.write(item.queue, function(err, chunks) {\n    if (err) {\n      return callback(self.error(constants.error.COMPRESSION_ERROR,\n                                 err.message));\n    }\n\n    var headers = {};\n    var size = 0;\n    for (var i = 0; i < chunks.length; i++) {\n      var header = chunks[i];\n\n      size += header.name.length + header.value.length + 32;\n      if (size >= self.maxHeaderListSize) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR,\n                                   'Header list is too large'));\n      }\n\n      if (/[A-Z]/.test(header.name)) {\n        return callback(self.error(constants.error.PROTOCOL_ERROR,\n                                   'Header name must be lowercase'));\n      }\n\n      utils.addHeaderLine(header.name, header.value, headers);\n    }\n\n    item.frame.headers = headers;\n    item.frame.path = headers[':path'];\n\n    callback(null, item.frame);\n  });\n};\n\nParser.prototype.onHeadersFrame = function onHeadersFrame(header,\n                                                          body,\n                                                          callback) {\n  var self = this;\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for HEADERS'));\n  }\n\n  this.unpadData(header, body, function(err, data) {\n    if (err)\n      return callback(err);\n\n    var isPriority = (header.flags & constants.flags.PRIORITY) !== 0;\n    if (!data.has(isPriority ? 5 : 0)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR,\n                                 'Not enough data for HEADERS'));\n    }\n\n    var exclusive = false;\n    var dependency = 0;\n    var weight = constants.DEFAULT_WEIGHT;\n    if (isPriority) {\n      dependency = data.readUInt32BE();\n      exclusive = (dependency & 0x80000000) !== 0;\n      dependency &= 0x7fffffff;\n\n      // Weight's range is [1, 256]\n      weight = data.readUInt8() + 1;\n    }\n\n    if (dependency === header.id) {\n      return callback(self.error(constants.error.PROTOCOL_ERROR,\n                                 'Stream can\\'t dependend on itself'));\n    }\n\n    var streamInfo = {\n      type: 'HEADERS',\n      id: header.id,\n      priority: {\n        parent: dependency,\n        exclusive: exclusive,\n        weight: weight\n      },\n      fin: (header.flags & constants.flags.END_STREAM) !== 0,\n      writable: true,\n      headers: null,\n      path: null\n    };\n\n    self.initHeaderBlock(header, streamInfo, data, callback);\n  });\n};\n\nParser.prototype.onContinuationFrame = function onContinuationFrame(header,\n                                                                    body,\n                                                                    callback) {\n  this.queueHeaderBlock(header, body, callback);\n};\n\nParser.prototype.onRSTFrame = function onRSTFrame(header, body, callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'RST_STREAM length not 4'));\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for RST_STREAM'));\n  }\n\n  callback(null, {\n    type: 'RST',\n    id: header.id,\n    code: constants.errorByCode[body.readUInt32BE()]\n  });\n};\n\nParser.prototype._validateSettings = function _validateSettings(settings) {\n  if (settings['enable_push'] !== undefined &&\n      settings['enable_push'] !== 0 &&\n      settings['enable_push'] !== 1)\n    return this.error(constants.error.PROTOCOL_ERROR,\n                      'SETTINGS_ENABLE_PUSH must be 0 or 1');\n\n  if ( settings['initial_window_size'] !== undefined &&\n      (settings['initial_window_size'] > constants.MAX_INITIAL_WINDOW_SIZE ||\n       settings['initial_window_size'] < 0))\n    return this.error(constants.error.FLOW_CONTROL_ERROR,\n                      'SETTINGS_INITIAL_WINDOW_SIZE is OOB');\n\n  if ( settings['max_frame_size'] !== undefined &&\n      (settings['max_frame_size'] > constants.ABSOLUTE_MAX_FRAME_SIZE ||\n       settings['max_frame_size'] < constants.INITIAL_MAX_FRAME_SIZE))\n    return this.error(constants.error.PROTOCOL_ERROR,\n                      'SETTINGS_MAX_FRAME_SIZE is OOB');\n\n  return undefined;\n};\n\nParser.prototype.onSettingsFrame = function onSettingsFrame(header,\n                                                            body,\n                                                            callback) {\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for SETTINGS'));\n  }\n\n  var isAck = (header.flags & constants.flags.ACK) !== 0;\n  if (isAck && body.size !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'SETTINGS with ACK and non-zero length'));\n  }\n\n  if (isAck)\n    return callback(null, { type: 'ACK_SETTINGS' });\n\n  if (body.size % 6 !== 0) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'SETTINGS length not multiple of 6'));\n  }\n\n  var settings = {};\n  while (!body.isEmpty()) {\n    var id = body.readUInt16BE();\n    var value = body.readUInt32BE();\n    var name = constants.settingsIndex[id];\n\n    if (name)\n      settings[name] = value;\n  }\n\n  var err = this._validateSettings(settings);\n  if (err !== undefined) {\n    return callback(err);\n  }\n\n  callback(null, {\n    type: 'SETTINGS',\n    settings: settings\n  });\n};\n\nParser.prototype.onPushPromiseFrame = function onPushPromiseFrame(header,\n                                                                  body,\n                                                                  callback) {\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for PUSH_PROMISE'));\n  }\n\n  var self = this;\n  this.unpadData(header, body, function(err, data) {\n    if (err)\n      return callback(err);\n\n    if (!data.has(4)) {\n      return callback(self.error(constants.error.FRAME_SIZE_ERROR,\n                                 'PUSH_PROMISE length less than 4'));\n    }\n\n    var streamInfo = {\n      type: 'PUSH_PROMISE',\n      id: header.id,\n      fin: false,\n      promisedId: data.readUInt32BE() & 0x7fffffff,\n      headers: null,\n      path: null\n    };\n\n    self.initHeaderBlock(header, streamInfo, data, callback);\n  });\n};\n\nParser.prototype.onPingFrame = function onPingFrame(header, body, callback) {\n  if (body.size !== 8) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'PING length != 8'));\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for PING'));\n  }\n\n  var ack = (header.flags & constants.flags.ACK) !== 0;\n  callback(null, { type: 'PING', opaque: body.take(body.size), ack: ack });\n};\n\nParser.prototype.onGoawayFrame = function onGoawayFrame(header,\n                                                        body,\n                                                        callback) {\n  if (!body.has(8)) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'GOAWAY length < 8'));\n  }\n\n  if (header.id !== 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for GOAWAY'));\n  }\n\n  var frame = {\n    type: 'GOAWAY',\n    lastId: body.readUInt32BE(),\n    code: constants.goawayByCode[body.readUInt32BE()]\n  };\n\n  if (body.size !== 0)\n    frame.debug = body.take(body.size);\n\n  callback(null, frame);\n};\n\nParser.prototype.onPriorityFrame = function onPriorityFrame(header,\n                                                            body,\n                                                            callback) {\n  if (body.size !== 5) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'PRIORITY length != 5'));\n  }\n\n  if (header.id === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Invalid stream id for PRIORITY'));\n  }\n\n  var dependency = body.readUInt32BE();\n\n  // Again the range is from 1 to 256\n  var weight = body.readUInt8() + 1;\n\n  if (dependency === header.id) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'Stream can\\'t dependend on itself'));\n  }\n\n  callback(null, {\n    type: 'PRIORITY',\n    id: header.id,\n    priority: {\n      exclusive: (dependency & 0x80000000) !== 0,\n      parent: dependency & 0x7fffffff,\n      weight: weight\n    }\n  });\n};\n\nParser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(header,\n                                                                    body,\n                                                                    callback) {\n  if (body.size !== 4) {\n    return callback(this.error(constants.error.FRAME_SIZE_ERROR,\n                               'WINDOW_UPDATE length != 4'));\n  }\n\n  var delta = body.readInt32BE();\n  if (delta === 0) {\n    return callback(this.error(constants.error.PROTOCOL_ERROR,\n                               'WINDOW_UPDATE delta == 0'));\n  }\n\n  callback(null, {\n    type: 'WINDOW_UPDATE',\n    id: header.id,\n    delta: delta\n  });\n};\n\nParser.prototype.onXForwardedFrame = function onXForwardedFrame(header,\n                                                                body,\n                                                                callback) {\n  callback(null, {\n    type: 'X_FORWARDED_FOR',\n    host: body.take(body.size).toString()\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/framer.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar base = transport.protocol.base;\nvar constants = require('./').constants;\n\nvar assert = require('assert');\nvar util = require('util');\nvar WriteBuffer = require('wbuf');\nvar OffsetBuffer = require('obuf');\nvar Buffer = require('buffer').Buffer;\nvar debug = require('debug')('spdy:framer');\nvar debugExtra = require('debug')('spdy:framer:extra');\n\nfunction Framer(options) {\n  base.Framer.call(this, options);\n\n  this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;\n}\nutil.inherits(Framer, base.Framer);\nmodule.exports = Framer;\n\nFramer.create = function create(options) {\n  return new Framer(options);\n};\n\nFramer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {\n  this.maxFrameSize = size;\n};\n\nFramer.prototype._frame = function _frame(frame, body, callback) {\n  debug('id=%d type=%s', frame.id, frame.type);\n\n  var buffer = new WriteBuffer();\n\n  buffer.reserve(constants.FRAME_HEADER_SIZE);\n  var len = buffer.skip(3);\n  buffer.writeUInt8(constants.frameType[frame.type]);\n  buffer.writeUInt8(frame.flags);\n  buffer.writeUInt32BE(frame.id & 0x7fffffff);\n\n  body(buffer);\n\n  var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;\n  len.writeUInt24BE(frameSize);\n\n  var chunks = buffer.render();\n  var toWrite = {\n    stream: frame.id,\n    priority: frame.priority === undefined ? false : frame.priority,\n    chunks: chunks,\n    callback: callback\n  };\n\n  if (this.window && frame.type === 'DATA') {\n    var self = this;\n    this._resetTimeout();\n    this.window.send.update(-frameSize, function() {\n      self._resetTimeout();\n      self.schedule(toWrite);\n    });\n  } else {\n    this._resetTimeout();\n    this.schedule(toWrite);\n  }\n\n  return chunks;\n};\n\nFramer.prototype._split = function _split(frame) {\n  var buf = new OffsetBuffer();\n  for (var i = 0; i < frame.chunks.length; i++)\n    buf.push(frame.chunks[i]);\n\n  var frames = [];\n  while (!buf.isEmpty()) {\n    // First frame may have reserved bytes in it\n    var size = this.maxFrameSize;\n    if (frames.length === 0)\n      size -= frame.reserve;\n    size = Math.min(size, buf.size);\n\n    var frameBuf = buf.clone(size);\n    buf.skip(size);\n\n    frames.push({\n      size: frameBuf.size,\n      chunks: frameBuf.toChunks()\n    });\n  }\n\n  return frames;\n};\n\nFramer.prototype._continuationFrame = function _continuationFrame(frame,\n                                                                  body,\n                                                                  callback) {\n  var frames = this._split(frame);\n\n  frames.forEach(function(subFrame, i) {\n    var isFirst = i === 0;\n    var isLast = i === frames.length - 1;\n\n    var flags = isLast ? constants.flags.END_HEADERS : 0;\n\n    // PRIORITY and friends\n    if (isFirst)\n      flags |= frame.flags;\n\n    this._frame({\n      id: frame.id,\n      priority: false,\n      type: isFirst ? frame.type : 'CONTINUATION',\n      flags: flags\n    }, function(buf) {\n      // Fill those reserved bytes\n      if (isFirst && body)\n        body(buf);\n\n      buf.reserve(subFrame.size);\n      for (var i = 0; i < subFrame.chunks.length; i++)\n        buf.copyFrom(subFrame.chunks[i]);\n    }, isLast ? callback : null);\n  }, this);\n\n  if (frames.length === 0) {\n    this._frame({\n      id: frame.id,\n      priority: false,\n      type: frame.type,\n      flags: frame.flags | constants.flags.END_HEADERS\n    }, function(buf) {\n      if (body)\n        body(buf);\n    }, callback);\n  }\n};\n\nFramer.prototype._compressHeaders = function _compressHeaders(headers,\n                                                              pairs,\n                                                              callback) {\n  Object.keys(headers || {}).forEach(function(name) {\n    var lowName = name.toLowerCase();\n\n    // Not allowed in HTTP2\n    switch(lowName) {\n      case 'host':\n      case 'connection':\n      case 'keep-alive':\n      case 'proxy-connection':\n      case 'transfer-encoding':\n      case 'upgrade':\n        return;\n    }\n\n    // Should be in `pairs`\n    if (/^:/.test(lowName))\n      return;\n\n    // Do not compress, or index Cookie field (for security reasons)\n    var neverIndex = lowName === 'cookie' || lowName === 'set-cookie';\n\n    var value = headers[name];\n    if (Array.isArray(value)) {\n      for (var i = 0; i < value.length; i++) {\n        pairs.push({\n          name: lowName,\n          value: value[i] + '',\n          neverIndex: neverIndex,\n          huffman: !neverIndex\n        });\n      }\n    } else {\n      pairs.push({\n        name: lowName,\n        value: value + '',\n        neverIndex: neverIndex,\n        huffman: !neverIndex\n      });\n    }\n  });\n\n  var self = this;\n  assert(this.compress !== null, 'Framer version not initialized');\n  debugExtra('compressing headers=%j', pairs);\n  this.compress.write([ pairs ], callback);\n};\n\nFramer.prototype._isDefaultPriority = function _isDefaultPriority(priority) {\n  if (!priority)\n    return true;\n\n  return !priority.parent &&\n         priority.weight === constants.DEFAULT &&\n         !priority.exclusive;\n};\n\nFramer.prototype._defaultHeaders = function _defaultHeaders(frame, pairs) {\n  if (!frame.path)\n    throw new Error('`path` is required frame argument');\n\n  pairs.push({\n    name: ':method',\n    value: frame.method || base.constants.DEFAULT_METHOD\n  });\n  pairs.push({ name: ':path', value: frame.path });\n  pairs.push({ name: ':scheme', value: frame.scheme || 'https' });\n  pairs.push({\n    name: ':authority',\n    value: frame.host ||\n           frame.headers && frame.headers.host ||\n           base.constants.DEFAULT_HOST\n  });\n};\n\nFramer.prototype._headersFrame = function _headersFrame(kind, frame, callback) {\n  var pairs = [];\n\n  if (kind === 'request') {\n    this._defaultHeaders(frame, pairs);\n  } else if (kind === 'response') {\n    pairs.push({ name: ':status', value: (frame.status || 200) + '' });\n  }\n\n  var self = this;\n  this._compressHeaders(frame.headers, pairs, function(err, chunks) {\n    if (err) {\n      if (callback)\n        return callback(err);\n      else\n        return self.emit('error', err);\n    }\n\n    var reserve = 0;\n\n    // If priority info is present, and the values are not default ones\n    // reserve space for the priority info and add PRIORITY flag\n    var priority = frame.priority;\n    if (!self._isDefaultPriority(priority))\n      reserve = 5;\n\n    var flags = reserve === 0 ? 0 : constants.flags.PRIORITY;\n\n    // Mostly for testing\n    if (frame.fin)\n      flags |= constants.flags.END_STREAM;\n\n    self._continuationFrame({\n      id: frame.id,\n      type: 'HEADERS',\n      flags: flags,\n      reserve: reserve,\n      chunks: chunks\n    }, function(buf) {\n      if (reserve === 0)\n        return;\n\n      buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |\n                        priority.parent);\n      buf.writeUInt8((priority.weight | 0) - 1);\n    }, callback);\n  });\n};\n\nFramer.prototype.requestFrame = function requestFrame(frame, callback) {\n  return this._headersFrame('request', frame, callback);\n};\n\nFramer.prototype.responseFrame = function responseFrame(frame, callback) {\n  return this._headersFrame('response', frame, callback);\n};\n\nFramer.prototype.headersFrame = function headersFrame(frame, callback) {\n  return this._headersFrame('headers', frame, callback);\n};\n\nFramer.prototype.pushFrame = function pushFrame(frame, callback) {\n  var self = this;\n\n  function compress(headers, pairs, callback) {\n    self._compressHeaders(headers, pairs, function(err, chunks) {\n      if (err) {\n        if (callback)\n          return callback(err);\n        else\n          return self.emit('error', err);\n      }\n\n      callback(chunks);\n    });\n  }\n\n  function sendPromise(chunks) {\n    self._continuationFrame({\n      id: frame.id,\n      type: 'PUSH_PROMISE',\n      reserve: 4,\n      chunks: chunks\n    }, function(buf) {\n      buf.writeUInt32BE(frame.promisedId);\n    });\n  }\n\n  function sendResponse(chunks, callback) {\n    var priority = frame.priority;\n    var isDefaultPriority = self._isDefaultPriority(priority);\n    var flags = isDefaultPriority ? 0 : constants.flags.PRIORITY;\n\n    // Mostly for testing\n    if (frame.fin)\n      flags |= constants.flags.END_STREAM;\n\n    self._continuationFrame({\n      id: frame.promisedId,\n      type: 'HEADERS',\n      flags: flags,\n      reserve: isDefaultPriority ? 0 : 5,\n      chunks: chunks\n    }, function(buf) {\n      if (isDefaultPriority)\n        return;\n\n      buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |\n                        priority.parent);\n      buf.writeUInt8((priority.weight | 0) - 1);\n    }, callback);\n  }\n\n  this._checkPush(function(err) {\n    if (err)\n      return callback(err);\n\n    var pairs = {\n      promise: [],\n      response: []\n    };\n\n    self._defaultHeaders(frame, pairs.promise);\n    pairs.response.push({ name: ':status', value: (frame.status || 200) + '' });\n\n    compress(frame.headers, pairs.promise, function(promiseChunks) {\n      sendPromise(promiseChunks);\n      compress(frame.response, pairs.response, function(responseChunks) {\n        sendResponse(responseChunks, callback);\n      });\n    });\n  });\n};\n\nFramer.prototype.priorityFrame = function priorityFrame(frame, callback) {\n  this._frame({\n    id: frame.id,\n    priority: false,\n    type: 'PRIORITY',\n    flags: 0\n  }, function(buf) {\n    var priority = frame.priority;\n    buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) |\n                      priority.parent);\n    buf.writeUInt8((priority.weight | 0) - 1);\n  }, callback);\n};\n\nFramer.prototype.dataFrame = function dataFrame(frame, callback) {\n  var frames = this._split({\n    reserve: 0,\n    chunks: [ frame.data ]\n  });\n\n  var fin = frame.fin ? constants.flags.END_STREAM : 0;\n\n  var self = this;\n  frames.forEach(function(subFrame, i) {\n    var isLast = i === frames.length - 1;\n    var flags = 0;\n    if (isLast)\n      flags |= fin;\n\n    self._frame({\n      id: frame.id,\n      priority: frame.priority,\n      type: 'DATA',\n      flags: flags\n    }, function(buf) {\n      buf.reserve(subFrame.size);\n      for (var i = 0; i < subFrame.chunks.length; i++)\n        buf.copyFrom(subFrame.chunks[i]);\n    }, isLast ? callback : null);\n  });\n\n  // Empty DATA\n  if (frames.length === 0) {\n    this._frame({\n      id: frame.id,\n      priority: frame.priority,\n      type: 'DATA',\n      flags: fin\n    }, function(buf) {\n      // No-op\n    }, callback);\n  }\n};\n\nFramer.prototype.pingFrame = function pingFrame(frame, callback) {\n  this._frame({\n    id: 0,\n    type: 'PING',\n    flags: frame.ack ? constants.flags.ACK : 0\n  }, function(buf) {\n    buf.copyFrom(frame.opaque);\n  }, callback);\n};\n\nFramer.prototype.rstFrame = function rstFrame(frame, callback) {\n  this._frame({\n    id: frame.id,\n    type: 'RST_STREAM',\n    flags: 0\n  }, function(buf) {\n    buf.writeUInt32BE(constants.error[frame.code]);\n  }, callback);\n};\n\nFramer.prototype.prefaceFrame = function prefaceFrame(callback) {\n  debug('preface');\n  this._resetTimeout();\n  this.schedule({\n    stream: 0,\n    priority: false,\n    chunks: [ constants.PREFACE_BUFFER ],\n    callback: callback\n  });\n};\n\nFramer.prototype.settingsFrame = function settingsFrame(options, callback) {\n  var key = JSON.stringify(options);\n\n  var settings = Framer.settingsCache[key];\n  if (settings) {\n    debug('cached settings');\n    this._resetTimeout();\n    this.schedule({\n      id: 0,\n      priority: false,\n      chunks: settings,\n      callback: callback\n    });\n    return;\n  }\n\n  var params = [];\n  for (var i = 0; i < constants.settingsIndex.length; i++) {\n    var name = constants.settingsIndex[i];\n    if (!name)\n      continue;\n\n    // value: Infinity\n    if (!isFinite(options[name]))\n      continue;\n\n    if (options[name] !== undefined)\n      params.push({ key: i, value: options[name] });\n  }\n\n  var bodySize = params.length * 6;\n\n  var chunks = this._frame({\n    id: 0,\n    type: 'SETTINGS',\n    flags: 0\n  }, function(buffer) {\n    buffer.reserve(bodySize);\n    for (var i = 0; i < params.length; i++) {\n      var param = params[i];\n\n      buffer.writeUInt16BE(param.key);\n      buffer.writeUInt32BE(param.value);\n    }\n  }, callback);\n\n  Framer.settingsCache[key] = chunks;\n};\nFramer.settingsCache = {};\n\nFramer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {\n  var chunks = this._frame({\n    id: 0,\n    type: 'SETTINGS',\n    flags: constants.flags.ACK\n  }, function(buffer) {\n    // No-op\n  }, callback);\n};\n\nFramer.prototype.windowUpdateFrame = function windowUpdateFrame(frame,\n                                                                callback) {\n  this._frame({\n    id: frame.id,\n    type: 'WINDOW_UPDATE',\n    flags: 0\n  }, function(buffer) {\n    buffer.reserve(4);\n    buffer.writeInt32BE(frame.delta);\n  }, callback);\n};\n\nFramer.prototype.goawayFrame = function goawayFrame(frame, callback) {\n  this._frame({\n    type: 'GOAWAY',\n    id: 0,\n    flags: 0\n  }, function(buf) {\n    buf.reserve(8);\n\n    // Last-good-stream-ID\n    buf.writeUInt32BE(frame.lastId & 0x7fffffff);\n    // Code\n    buf.writeUInt32BE(constants.goaway[frame.code]);\n\n    // Extra debugging information\n    if (frame.extra)\n      buf.write(frame.extra);\n  }, callback);\n};\n\nFramer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {\n  this._frame({\n    type: 'X_FORWARDED_FOR',\n    id: 0,\n    flags: 0\n  }, function(buf) {\n    buf.write(frame.host);\n  }, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/protocol/http2/hpack-pool.js":"'use strict';\n\nvar transport = require('../../../spdy-transport');\nvar constants = require('./').constants;\n\nvar hpack = require('hpack.js');\n\nfunction Pool() {\n}\nmodule.exports = Pool;\n\nPool.create = function create() {\n  return new Pool();\n};\n\nPool.prototype.get = function get(version) {\n  var options = {\n    table: {\n      maxSize: constants.HEADER_TABLE_SIZE\n    }\n  };\n\n  var compress = hpack.compressor.create(options);\n  var decompress = hpack.decompressor.create(options);\n\n  return {\n    version: version,\n\n    compress: compress,\n    decompress: decompress\n  };\n};\n\nPool.prototype.put = function put() {\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/window.js":"'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar debug = {\n  server: require('debug')('spdy:window:server'),\n  client: require('debug')('spdy:window:client')\n};\n\nfunction Side(window, name, options) {\n  EventEmitter.call(this);\n\n  this.name = name;\n  this.window = window;\n  this.current = options.size;\n  this.max = options.size;\n  this.limit = options.max;\n  this.lowWaterMark = options.lowWaterMark === undefined ?\n      this.max / 2 :\n      options.lowWaterMark;\n\n  this._refilling = false;\n  this._refillQueue = [];\n}\nutil.inherits(Side, EventEmitter);\n\nSide.prototype.setMax = function setMax(max) {\n  this.window.debug('id=%d side=%s setMax=%d',\n                    this.window.id,\n                    this.name,\n                    max);\n  this.max = max;\n  this.lowWaterMark = this.max / 2;\n};\n\nSide.prototype.updateMax = function updateMax(max) {\n  var delta = max - this.max;\n  this.window.debug('id=%d side=%s updateMax=%d delta=%d',\n                    this.window.id,\n                    this.name,\n                    max,\n                    delta);\n\n  this.max = max;\n  this.lowWaterMark = max / 2;\n\n  this.update(delta);\n};\n\nSide.prototype.setLowWaterMark = function setLowWaterMark(lwm) {\n  this.lowWaterMark = lwm;\n};\n\nSide.prototype.update = function update(size, callback) {\n  // Not enough space for the update, wait for refill\n  if (size <= 0 && callback && this.isEmpty()) {\n    this.window.debug('id=%d side=%s wait for refill=%d [%d/%d]',\n                      this.window.id,\n                      this.name,\n                      -size,\n                      this.current,\n                      this.max);\n    this._refillQueue.push({\n      size: size,\n      callback: callback\n    });\n    return;\n  }\n\n  this.current += size;\n\n  if (this.current > this.limit) {\n    this.emit('overflow');\n    return;\n  }\n\n  this.window.debug('id=%d side=%s update by=%d [%d/%d]',\n                    this.window.id,\n                    this.name,\n                    size,\n                    this.current,\n                    this.max);\n\n  // Time to send WINDOW_UPDATE\n  if (size < 0 && this.isDraining()) {\n    this.window.debug('id=%d side=%s drained', this.window.id, this.name);\n    this.emit('drain');\n  }\n\n  // Time to write\n  if (size > 0 && this.current > 0 && this.current <= size) {\n    this.window.debug('id=%d side=%s full', this.window.id, this.name);\n    this.emit('full');\n  }\n\n  this._processRefillQueue();\n\n  if (callback)\n    process.nextTick(callback);\n};\n\nSide.prototype.getCurrent = function getCurrent() {\n  return this.current;\n};\n\nSide.prototype.getMax = function getMax() {\n  return this.max;\n};\n\nSide.prototype.getDelta = function getDelta() {\n  return this.max - this.current;\n};\n\nSide.prototype.isDraining = function isDraining() {\n  return this.current <= this.lowWaterMark;\n};\n\nSide.prototype.isEmpty = function isEmpty() {\n  return this.current <= 0;\n};\n\n// Private\n\nSide.prototype._processRefillQueue = function _processRefillQueue() {\n  // Prevent recursion\n  if (this._refilling)\n    return;\n  this._refilling = true;\n\n  while (this._refillQueue.length > 0) {\n    var item = this._refillQueue[0];\n\n    if (this.isEmpty())\n      break;\n\n    this.window.debug('id=%d side=%s refilled for size=%d',\n                      this.window.id,\n                      this.name,\n                      -item.size);\n\n    this._refillQueue.shift();\n    this.update(item.size, item.callback);\n  }\n\n  this._refilling = false;\n};\n\nfunction Window(options) {\n  this.id = options.id;\n  this.isServer = options.isServer;\n  this.debug = this.isServer ? debug.server : debug.client;\n\n  this.recv = new Side(this, 'recv', options.recv);\n  this.send = new Side(this, 'send', options.send);\n}\nmodule.exports = Window;\n\nWindow.prototype.clone = function clone(id) {\n  return new Window({\n    id: id,\n    isServer: this.isServer,\n    recv: {\n      size: this.recv.max,\n      max: this.recv.limit,\n      lowWaterMark: this.recv.lowWaterMark\n    },\n    send: {\n      size: this.send.max,\n      max: this.send.limit,\n      lowWaterMark: this.send.lowWaterMark\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/priority.js":"'use strict';\n\nvar transport = require('../spdy-transport');\nvar utils = transport.utils;\n\nvar assert = require('assert');\nvar debug = require('debug')('spdy:priority');\n\nfunction PriorityNode(tree, options) {\n  this.tree = tree;\n\n  this.id = options.id;\n  this.parent = options.parent;\n  this.weight = options.weight;\n\n  // To be calculated in `addChild`\n  this.priorityFrom = 0;\n  this.priorityTo = 1;\n  this.priority = 1;\n\n  this.children = {\n    list: [],\n    weight: 0\n  };\n\n  if (this.parent !== null)\n    this.parent.addChild(this);\n}\n\nfunction compareChildren(a, b) {\n  return a.weight === b.weight ? a.id - b.id : a.weight - b.weight;\n}\n\nPriorityNode.prototype.toJSON = function toJSON() {\n  return {\n    parent: this.parent,\n    weight: this.weight,\n    exclusive: this.exclusive\n  };\n};\n\nPriorityNode.prototype.getPriority = function getPriority() {\n  return this.priority;\n};\n\nPriorityNode.prototype.getPriorityRange = function getPriorityRange() {\n  return { from: this.priorityFrom, to: this.priorityTo };\n};\n\nPriorityNode.prototype.addChild = function addChild(child) {\n  child.parent = this;\n  utils.binaryInsert(this.children.list, child, compareChildren);\n  this.children.weight += child.weight;\n\n  this._updatePriority(this.priorityFrom, this.priorityTo);\n};\n\nPriorityNode.prototype.remove = function remove() {\n  assert(this.parent, 'Can\\'t remove root node');\n\n  this.parent.removeChild(this);\n  this.tree._removeNode(this);\n\n  // Move all children to the parent\n  for (var i = 0; i < this.children.list.length; i++)\n    this.parent.addChild(this.children.list[i]);\n};\n\nPriorityNode.prototype.removeChild = function removeChild(child) {\n  this.children.weight -= child.weight;\n  var index = utils.binarySearch(this.children.list, child, compareChildren);\n  assert(index !== -1);\n\n  // Remove the child\n  this.children.list.splice(index, 1);\n};\n\nPriorityNode.prototype.removeChildren = function removeChildren() {\n  var children = this.children.list;\n  this.children.list = [];\n  this.children.weight = 0;\n  return children;\n};\n\nPriorityNode.prototype._updatePriority = function _updatePriority(from, to) {\n  this.priority = to - from;\n  this.priorityFrom = from;\n  this.priorityTo = to;\n\n  var weight = 0;\n  for (var i = 0; i < this.children.list.length; i++) {\n    var node = this.children.list[i];\n    var nextWeight = weight + node.weight;\n\n    node._updatePriority(\n      from + this.priority * (weight / this.children.weight),\n      from + this.priority * (nextWeight / this.children.weight)\n    );\n    weight = nextWeight;\n  }\n};\n\nfunction PriorityTree(options) {\n  this.map = {};\n  this.list = [];\n  this.defaultWeight = options.defaultWeight || 16;\n\n  this.count = 0;\n  this.maxCount = options.maxCount;\n\n  // Root\n  this.root = this.add({\n    id: 0,\n    parent: null,\n    weight: 1\n  });\n}\nmodule.exports = PriorityTree;\n\nPriorityTree.create = function create(options) {\n  return new PriorityTree(options);\n};\n\nPriorityTree.prototype.add = function add(options) {\n  if (options.id === options.parent)\n    return this.addDefault(options.id);\n\n  var parent = options.parent === null ? null : this.map[options.parent];\n  if (parent === undefined)\n    return this.addDefault(options.id);\n\n  debug('add node=%d parent=%d weight=%d exclusive=%d',\n        options.id,\n        options.parent === null ? -1 : options.parent,\n        options.weight || this.defaultWeight,\n        options.exclusive ? 1 : 0);\n\n  var children;\n  if (options.exclusive)\n    children = parent.removeChildren();\n\n  var node = new PriorityNode(this, {\n    id: options.id,\n    parent: parent,\n    weight: options.weight || this.defaultWeight\n  });\n  this.map[options.id] = node;\n\n  if (options.exclusive) {\n    for (var i = 0; i < children.length; i++)\n      node.addChild(children[i]);\n  }\n\n  this.count++;\n  if (this.count > this.maxCount) {\n    debug('hit maximum remove id=%d', this.list[0].id);\n    this.list.shift().remove();\n  }\n\n  // Root node is not subject to removal\n  if (node.parent !== null)\n    this.list.push(node);\n\n  return node;\n};\n\n// Only for testing, should use `node`'s methods\nPriorityTree.prototype.get = function get(id) {\n  return this.map[id];\n};\n\nPriorityTree.prototype.addDefault = function addDefault(id) {\n  debug('creating default node');\n  return this.add({ id: id, parent: 0, weight: this.defaultWeight });\n};\n\nPriorityTree.prototype._removeNode = function _removeNode(node) {\n  delete this.map[node.id];\n  this.count--;\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/stream.js":"'use strict';\n\nvar transport = require('../spdy-transport');\n\nvar assert = require('assert');\nvar util = require('util');\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n};\nvar Buffer = require('buffer').Buffer;\nvar Duplex = require('readable-stream').Duplex;\n\nfunction Stream(connection, options) {\n  Duplex.call(this);\n\n  var connectionState = connection._spdyState;\n\n  var state = {};\n  this._spdyState = state;\n\n  this.id = options.id;\n  this.method = options.method;\n  this.path = options.path;\n  this.host = options.host;\n  this.headers = options.headers || {};\n  this.connection = connection;\n  this.parent = options.parent || null;\n\n  state.socket = null;\n  state.protocol = connectionState.protocol;\n  state.constants = state.protocol.constants;\n\n  // See _initPriority()\n  state.priority = null;\n\n  state.version = this.connection.getVersion();\n  state.isServer = this.connection.isServer();\n  state.debug = state.isServer ? debug.server : debug.client;\n\n  state.framer = connectionState.framer;\n  state.parser = connectionState.parser;\n\n  state.request = options.request;\n  state.needResponse = options.request;\n  state.window = connectionState.streamWindow.clone(options.id);\n  state.sessionWindow = connectionState.window;\n  state.maxChunk = connectionState.maxChunk;\n\n  // Can't send incoming request\n  // (See `.send()` method)\n  state.sent = !state.request;\n\n  state.readable = options.readable !== false;\n  state.writable = options.writable !== false;\n\n  state.aborted = false;\n\n  state.corked = 0;\n  state.corkQueue = [];\n\n  state.timeout = new transport.utils.Timeout(this);\n\n  this.on('finish', this._onFinish);\n  this.on('end', this._onEnd);\n\n  var self = this;\n  function _onWindowOverflow() {\n    self._onWindowOverflow();\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow);\n  state.window.send.on('overflow', _onWindowOverflow);\n\n  this._initPriority(options.priority);\n\n  if (!state.readable)\n    this.push(null);\n  if (!state.writable) {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n}\nutil.inherits(Stream, Duplex);\nexports.Stream = Stream;\n\nStream.prototype._init = function _init(socket) {\n  this.socket = socket;\n};\n\nStream.prototype._initPriority = function _initPriority(priority) {\n  var state = this._spdyState;\n  var connectionState = this.connection._spdyState;\n  var root = connectionState.priorityRoot;\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id);\n    return;\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  });\n};\n\nStream.prototype._handleFrame = function _handleFrame(frame) {\n  var state = this._spdyState;\n\n  // Ignore any kind of data after abort\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);\n    return;\n  }\n\n  // Restart the timer on incoming frames\n  state.timeout.reset();\n\n  if (frame.type === 'DATA')\n    this._handleData(frame);\n  else if (frame.type === 'HEADERS')\n    this._handleHeaders(frame);\n  else if (frame.type === 'RST')\n    this._handleRST(frame);\n  else if (frame.type === 'WINDOW_UPDATE')\n    this._handleWindowUpdate(frame);\n  else if (frame.type === 'PRIORITY')\n    this._handlePriority(frame);\n  else if (frame.type === 'PUSH_PROMISE')\n    this._handlePushPromise(frame);\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id);\n    this.push(null);\n  }\n};\n\nfunction checkAborted(stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id);\n    process.nextTick(function() {\n      callback(new Error('Stream write aborted'));\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction _send(stream, state, data, callback) {\n  if (checkAborted(stream, state, callback))\n    return;\n\n  state.debug('id=%d presend=%d', stream.id, data.length);\n\n  state.timeout.reset();\n\n  state.window.send.update(-data.length, function() {\n    if (checkAborted(stream, state, callback))\n      return;\n\n    state.debug('id=%d send=%d', stream.id, data.length);\n\n    state.timeout.reset();\n\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function(err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length);\n      callback(err);\n    });\n  });\n}\n\nStream.prototype._write = function _write(data, enc, callback) {\n  var state = this._spdyState;\n\n  // Send the request if it wasn't sent\n  if (!state.sent)\n    this.send();\n\n  // Writes should come after pending control frames (response and headers)\n  if (state.corked !== 0) {\n    var self = this;\n    state.corkQueue.push(function() {\n      self._write(data, enc, callback);\n    });\n    return;\n  }\n\n  // Split DATA in chunks to prevent window from going negative\n  this._splitStart(data, _send, callback);\n};\n\nStream.prototype._splitStart = function _splitStart(data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback);\n};\n\nStream.prototype._split = function _split(data, offset, onChunk, callback) {\n  if (offset === data.length)\n    return process.nextTick(callback);\n\n  var state = this._spdyState;\n  var local = state.window.send;\n  var session = state.sessionWindow.send;\n\n  var availSession = Math.max(0, session.getCurrent());\n  if (availSession === 0)\n    availSession = session.getMax();\n  var availLocal = Math.max(0, local.getCurrent());\n  if (availLocal === 0)\n    availLocal = local.getMax();\n\n  var avail = Math.min(availSession, availLocal);\n  avail = Math.min(avail, state.maxChunk);\n\n  if (avail === 0) {\n    var self = this;\n    state.window.send.update(0, function() {\n      self._split(data, offset, onChunk, callback);\n    });\n    return;\n  }\n\n  // Split data in chunks in a following way:\n  var limit = avail;\n  var size = Math.min(data.length - offset, limit);\n\n  var chunk = data.slice(offset, offset + size);\n\n  var self = this;\n  onChunk(this, state, chunk, function(err) {\n    if (err)\n      return callback(err);\n\n    // Get the next chunk\n    self._split(data, offset + size, onChunk, callback);\n  });\n};\n\nStream.prototype._read = function _read() {\n  var state = this._spdyState;\n\n  if (!state.window.recv.isDraining())\n    return;\n\n  var delta = state.window.recv.getDelta();\n\n  state.debug('id=%d window emptying, update by %d', this.id, delta);\n\n  state.window.recv.update(delta);\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n};\n\nStream.prototype._handleData = function _handleData(frame) {\n  var state = this._spdyState;\n\n  // DATA on ended or not readable stream!\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' });\n    return;\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length);\n  state.window.recv.update(-frame.data.length);\n\n  this.push(frame.data);\n};\n\nStream.prototype._handleRST = function _handleRST(frame) {\n  if (frame.code !== 'CANCEL')\n    this.emit('error', new Error('Got RST: ' + frame.code));\n  this.abort();\n};\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {\n  var state = this._spdyState;\n\n  state.window.send.update(frame.delta);\n};\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow() {\n  var state = this._spdyState;\n\n  state.debug('id=%d window overflow', this.id);\n  state.framer.rstFrame({ id: this.id, code: 'FLOW_CONTROL_ERROR' });\n\n  this.aborted = true;\n  this.emit('error', new Error('HTTP2 window overflow'));\n};\n\nStream.prototype._handlePriority = function _handlePriority(frame) {\n  var state = this._spdyState;\n\n  state.priority.remove();\n  state.priority = null;\n  this._initPriority(frame.priority);\n\n  // Mostly for testing purposes\n  this.emit('priority', frame.priority);\n};\n\nStream.prototype._handleHeaders = function _handleHeaders(frame) {\n  var state = this._spdyState;\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' });\n    return;\n  }\n\n  if (state.needResponse)\n    return this._handleResponse(frame);\n\n  this.emit('headers', frame.headers);\n};\n\nStream.prototype._handleResponse = function _handleResponse(frame) {\n  var state = this._spdyState;\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({ id: this.id, code: 'PROTOCOL_ERROR' });\n    return;\n  }\n\n  state.needResponse = false;\n  this.emit('response', frame.headers[':status'] | 0, frame.headers);\n};\n\nStream.prototype._onFinish = function _onFinish() {\n  var state = this._spdyState;\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send();\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this;\n      state.corkQueue.push(function() {\n        self._onFinish();\n      });\n      return;\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: new Buffer(0)\n    });\n  }\n\n  this._maybeClose();\n};\n\nStream.prototype._onEnd = function _onEnd() {\n  this._maybeClose();\n};\n\nStream.prototype._checkEnded = function _checkEnded(callback) {\n  var state = this._spdyState;\n\n  var ended = false;\n  if (state.aborted)\n    ended = true;\n\n  if (!state.writable || this._writableState.finished)\n    ended = true;\n\n  if (!ended)\n    return true;\n\n  if (!callback)\n    return false;\n\n  var err = new Error('Ended stream can\\'t send frames');\n  process.nextTick(function() {\n    callback(err);\n  });\n\n  return false;\n};\n\nStream.prototype._maybeClose = function _maybeClose() {\n  var state = this._spdyState;\n\n  // .abort() emits `close`\n  if (state.aborted)\n    return;\n\n  if ((!state.readable || this._readableState.ended) &&\n      this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0);\n\n    this.emit('close');\n  }\n};\n\nStream.prototype._handlePushPromise = function _handlePushPromise(frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  });\n\n  // GOAWAY\n  if (this.connection._isGoaway(push.id))\n    return;\n\n  if (!this.emit('pushPromise', push))\n    push.abort();\n};\n\nStream.prototype._hardCork = function _hardCork() {\n  var state = this._spdyState;\n\n  this.cork();\n  state.corked++;\n};\n\nStream.prototype._hardUncork = function _hardUncork() {\n  var state = this._spdyState;\n\n  this.uncork();\n  state.corked--;\n  if (state.corked !== 0)\n    return;\n\n  // Invoke callbacks\n  var queue = state.corkQueue;\n  state.corkQueue = [];\n  for (var i = 0; i < queue.length; i++)\n    queue[i]();\n};\n\nStream.prototype._sendPush = function _sendPush(status, response, callback) {\n  var self = this;\n  var state = this._spdyState;\n\n  this._hardCork();\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function(err) {\n    self._hardUncork();\n\n    callback(err);\n  });\n};\n\nStream.prototype._wasSent = function _wasSent() {\n  var state = this._spdyState;\n  return state.sent;\n};\n\n// Public API\n\nStream.prototype.send = function send(callback) {\n  var state = this._spdyState;\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent');\n    process.nextTick(function() {\n      if (callback)\n        callback(err);\n    });\n    return;\n  }\n\n  state.sent = true;\n  state.timeout.reset();\n\n  // GET requests should always be auto-finished\n  if (this.method === 'GET') {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n\n  // TODO(indunty): ideally it should just take a stream object as an input\n  var self = this;\n  this._hardCork();\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function(err) {\n    self._hardUncork();\n\n    if (!callback)\n      return;\n\n    callback(err);\n  });\n};\n\nStream.prototype.respond = function respond(status, headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  assert(!state.request, 'Can\\'t respond on request');\n\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback))\n    return;\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  };\n  this._hardCork();\n  state.framer.responseFrame(frame, function(err) {\n    self._hardUncork();\n    if (callback)\n      callback(err);\n  });\n};\n\nStream.prototype.setWindow = function setWindow(size) {\n  var state = this._spdyState;\n\n  state.timeout.reset();\n\n  if (!this._checkEnded())\n    return;\n\n  state.debug('id=%d force window max=%d', this.id, size);\n  state.window.recv.setMax(size);\n\n  var delta = state.window.recv.getDelta();\n  if (delta === 0)\n    return;\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n  state.window.recv.update(delta);\n};\n\nStream.prototype.sendHeaders = function sendHeaders(headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback))\n    return;\n\n  // Request wasn't yet send, coalesce headers\n  if (!state.sent) {\n    this.headers = util._extend({}, this.headers);\n    util._extend(this.headers, headers);\n    process.nextTick(function() {\n      if (callback)\n        callback(null);\n    });\n    return;\n  }\n\n  this._hardCork();\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function(err) {\n    self._hardUncork();\n    if (callback)\n      callback(err);\n  });\n};\n\nStream.prototype.destroy = function destroy() {\n  this.abort();\n};\n\nStream.prototype.abort = function abort(code, callback) {\n  var state = this._spdyState;\n\n  // .abort(callback)\n  if (typeof code === 'function') {\n    callback = code;\n    code = null;\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id);\n    if (callback)\n      process.nextTick(callback);\n    return;\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id);\n    if (callback)\n      process.nextTick(callback);\n    return;\n  }\n\n  state.aborted = true;\n  state.debug('id=%d abort', this.id);\n\n  this.setTimeout(0);\n\n  var abortCode = code || 'CANCEL';\n\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  });\n\n  var self = this;\n  process.nextTick(function() {\n    if (callback)\n      callback(null);\n    self.emit('close', new Error('Aborted, code: ' + abortCode));\n  });\n};\n\nStream.prototype.setPriority = function setPriority(info) {\n  var state = this._spdyState;\n\n  state.timeout.reset();\n\n  if (!this._checkEnded())\n    return;\n\n  state.debug('id=%d priority change', this.id, info);\n\n  var frame = { id: this.id, priority: info };\n\n  // Change priority on this side\n  this._handlePriority(frame);\n\n  // And on the other too\n  state.framer.priorityFrame(frame);\n};\n\nStream.prototype.pushPromise = function pushPromise(uri, callback) {\n  if (!this._checkEnded(callback))\n    return;\n\n  var self = this;\n  this._hardCork();\n  var push = this.connection.pushPromise(this, uri, function(err) {\n    self._hardUncork();\n    if (!err)\n      push._hardUncork();\n\n    if (callback)\n      return callback(err, push);\n\n    if (err)\n      push.emit('error', err);\n  });\n  push._hardCork();\n\n  return push;\n};\n\nStream.prototype.setMaxChunk = function setMaxChunk(size) {\n  var state = this._spdyState;\n  state.maxChunk = size;\n};\n\nStream.prototype.setTimeout = function setTimeout(delay, callback) {\n  var state = this._spdyState;\n\n  state.timeout.set(delay, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy-transport/lib/spdy-transport/connection.js":"'use strict';\n\nvar util = require('util');\nvar transport = require('../spdy-transport');\n\nvar debug = {\n  server: require('debug')('spdy:connection:server'),\n  client: require('debug')('spdy:connection:client')\n};\nvar EventEmitter = require('events').EventEmitter;\n\nvar Stream = transport.Stream;\n\nfunction Connection(socket, options) {\n  EventEmitter.call(this);\n\n  var state = {};\n  this._spdyState = state;\n\n  // NOTE: There's a big trick here. Connection is used as a `this` argument\n  // to the wrapped `connection` event listener.\n  // socket end doesn't necessarly mean connection drop\n  this.httpAllowHalfOpen = true;\n\n  state.timeout = new transport.utils.Timeout(this);\n\n  // Protocol info\n  state.protocol = transport.protocol[options.protocol];\n  state.version = null;\n  state.constants = state.protocol.constants;\n  state.pair = null;\n  state.isServer = options.isServer;\n\n  // Root of priority tree (i.e. stream id = 0)\n  state.priorityRoot = new transport.Priority({\n    defaultWeight: state.constants.DEFAULT_WEIGHT,\n    maxCount: transport.protocol.base.constants.MAX_PRIORITY_STREAMS\n  });\n\n  // Defaults\n  state.maxStreams = options.maxStreams ||\n                     state.constants.MAX_CONCURRENT_STREAMS;\n\n  state.autoSpdy31 = options.protocol.name !== 'h2' && options.autoSpdy31;\n  state.acceptPush = options.acceptPush === undefined ?\n      !state.isServer :\n      options.acceptPush;\n\n  if (options.maxChunk === false)\n    state.maxChunk = Infinity;\n  else if (options.maxChunk === undefined)\n    state.maxChunk = transport.protocol.base.constants.DEFAULT_MAX_CHUNK;\n  else\n    state.maxChunk = options.maxChunk;\n\n  // Connection-level flow control\n  var windowSize = options.windowSize || 1 << 20;\n  state.window = new transport.Window({\n    id: 0,\n    isServer: state.isServer,\n    recv: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    },\n    send: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    }\n  });\n\n  // It starts with DEFAULT_WINDOW, update must be sent to change it on client\n  state.window.recv.setMax(windowSize);\n\n  // Boilerplate for Stream constructor\n  state.streamWindow = new transport.Window({\n    id: -1,\n    isServer: state.isServer,\n    recv: {\n      size: windowSize,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    },\n    send: {\n      size: state.constants.DEFAULT_WINDOW,\n      max: state.constants.MAX_INITIAL_WINDOW_SIZE\n    }\n  });\n\n  // Various state info\n  state.pool = state.protocol.compressionPool.create(options.headerCompression);\n  state.counters = {\n    push: 0,\n    stream: 0\n  };\n\n  // Init streams list\n  state.stream = {\n    map: {},\n    count: 0,\n    nextId: state.isServer ? 2 : 1,\n    lastId: {\n      both: 0,\n      received: 0\n    }\n  };\n  state.ping = {\n    nextId: state.isServer ? 2 : 1,\n    map: {}\n  };\n  state.goaway = false;\n\n  // Debug\n  state.debug = state.isServer ? debug.server : debug.client;\n\n  // X-Forwarded feature\n  state.xForward = null;\n\n  // Create parser and hole for framer\n  state.parser = state.protocol.parser.create({\n    // NOTE: needed to distinguish ping from ping ACK in SPDY\n    isServer: state.isServer,\n    window: state.window\n  });\n  state.framer = state.protocol.framer.create({\n    window: state.window,\n    timeout: state.timeout\n  });\n\n  // SPDY has PUSH enabled on servers\n  if (state.protocol.name === 'spdy')\n    state.framer.enablePush(state.isServer);\n\n  if (!state.isServer)\n    state.parser.skipPreface();\n\n  this.socket = socket;\n\n  this._init();\n}\nutil.inherits(Connection, EventEmitter);\nexports.Connection = Connection;\n\nConnection.create = function create(socket, options) {\n  return new Connection(socket, options);\n};\n\nConnection.prototype._init = function init() {\n  var self = this;\n  var state = this._spdyState;\n  var pool = state.pool;\n\n  // Initialize session window\n  state.window.recv.on('drain', function() {\n    self._onSessionWindowDrain();\n  });\n\n  // Initialize parser\n  state.parser.on('data', function(frame) {\n    self._handleFrame(frame);\n  });\n  state.parser.once('version', function(version) {\n    self._onVersion(version);\n  });\n\n  // Propagate parser errors\n  state.parser.on('error', function(err) {\n    self._onParserError(err);\n  });\n\n  // Propagate framer errors\n  state.framer.on('error', function(err) {\n    self.emit('error', err);\n  });\n\n  this.socket.pipe(state.parser);\n  state.framer.pipe(this.socket);\n\n  // Allow high-level api to catch socket errors\n  this.socket.on('error', function onSocketError(e) {\n    self.emit('error', e);\n  });\n\n  this.socket.once('close', function onclose() {\n    var err = new Error('socket hang up');\n    err.code = 'ECONNRESET';\n    self.destroyStreams(err);\n    self.emit('close', err);\n\n    if (state.pair)\n      pool.put(state.pair);\n\n    state.framer.resume();\n  });\n\n  // Reset timeout on close\n  this.once('close', function() {\n    self.setTimeout(0);\n  });\n\n  function _onWindowOverflow() {\n    self._onWindowOverflow();\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow);\n  state.window.send.on('overflow', _onWindowOverflow);\n\n  // Do not allow half-open connections\n  this.socket.allowHalfOpen = false;\n};\n\nConnection.prototype._onVersion = function _onVersion(version) {\n  var state = this._spdyState;\n  var prev = state.version;\n  var parser = state.parser;\n  var framer = state.framer;\n  var pool = state.pool;\n\n  state.version = version;\n  state.debug('id=0 version=%d', version);\n\n  // Ignore transition to 3.1\n  if (!prev) {\n    state.pair = pool.get(version);\n    parser.setCompression(state.pair);\n    framer.setCompression(state.pair);\n  }\n  framer.setVersion(version);\n\n  if (!state.isServer) {\n    framer.prefaceFrame();\n    if (state.xForward !== null)\n      framer.xForwardedFor({ host: state.xForward });\n  }\n\n  // Send preface+settings frame (once)\n  framer.settingsFrame({\n    max_header_list_size: state.constants.DEFAULT_MAX_HEADER_LIST_SIZE,\n    max_concurrent_streams: state.maxStreams,\n    enable_push: state.acceptPush ? 1 : 0,\n    initial_window_size: state.window.recv.max\n  });\n\n  // Update session window\n  if (state.version >= 3.1 || (state.isServer && state.autoSpdy31))\n    this._onSessionWindowDrain();\n\n  this.emit('version', version);\n};\n\nConnection.prototype._onParserError = function _onParserError(err) {\n  var state = this._spdyState;\n\n  // Prevent further errors\n  state.parser.kill();\n\n  // Send GOAWAY\n  if (err instanceof transport.protocol.base.utils.ProtocolError) {\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: err.code,\n      extra: err.message,\n      send: true\n    });\n  }\n\n  this.emit('error', err);\n};\n\nConnection.prototype._handleFrame = function _handleFrame(frame) {\n  var state = this._spdyState;\n\n  state.debug('id=0 frame', frame);\n  state.timeout.reset();\n\n  // For testing purposes\n  this.emit('frame', frame);\n\n  var stream;\n\n  // Session window update\n  if (frame.type === 'WINDOW_UPDATE' && frame.id === 0) {\n    if (state.version < 3.1 && state.autoSpdy31) {\n      state.debug('id=0 switch version to 3.1');\n      state.version = 3.1;\n      this.emit('version', 3.1);\n    }\n    state.window.send.update(frame.delta);\n    return;\n  }\n\n  if (state.isServer && frame.type === 'PUSH_PROMISE') {\n    state.debug('id=0 server PUSH_PROMISE');\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: 'PROTOCOL_ERROR',\n      send: true\n    });\n    return;\n  }\n\n  if (!stream && frame.id !== undefined) {\n    // Load created one\n    stream = state.stream.map[frame.id];\n\n    // Fail if not found\n    if (!stream &&\n        frame.type !== 'HEADERS' &&\n        frame.type !== 'PRIORITY' &&\n        frame.type !== 'RST') {\n      // Other side should destroy the stream upon receiving GOAWAY\n      if (this._isGoaway(frame.id))\n        return;\n\n      state.debug('id=0 stream=%d not found', frame.id);\n      state.framer.rstFrame({ id: frame.id, code: 'INVALID_STREAM' });\n      return;\n    }\n  }\n\n  // Create new stream\n  if (!stream && frame.type === 'HEADERS') {\n    this._handleHeaders(frame);\n    return;\n  }\n\n  if (stream) {\n    stream._handleFrame(frame);\n  } else if (frame.type === 'SETTINGS') {\n    this._handleSettings(frame.settings);\n  } else if (frame.type === 'ACK_SETTINGS') {\n    // TODO(indutny): handle it one day\n  } else if (frame.type === 'PING') {\n    this._handlePing(frame);\n  } else if (frame.type === 'GOAWAY') {\n    this._handleGoaway(frame);\n  } else if (frame.type === 'X_FORWARDED_FOR') {\n    // Set X-Forwarded-For only once\n    if (state.xForward === null)\n      state.xForward = frame.host;\n  } else if (frame.type === 'PRIORITY') {\n    // TODO(indutny): handle this\n  } else {\n    state.debug('id=0 unknown frame type: %s', frame.type);\n  }\n};\n\nConnection.prototype._onWindowOverflow = function _onWindowOverflow() {\n  var state = this._spdyState;\n  state.debug('id=0 window overflow');\n  this._goaway({\n    lastId: state.stream.lastId.both,\n    code: 'FLOW_CONTROL_ERROR',\n    send: true\n  });\n};\n\nConnection.prototype._isGoaway = function _isGoaway(id) {\n  var state = this._spdyState;\n  if (state.goaway !== false && state.goaway < id)\n    return true;\n  return false;\n};\n\nConnection.prototype._getId = function _getId() {\n  var state = this._spdyState;\n\n  var id = state.stream.nextId;\n  state.stream.nextId += 2;\n  return id;\n};\n\nConnection.prototype._createStream = function _createStream(uri) {\n  var state = this._spdyState;\n  var id = uri.id;\n  if (id === undefined)\n    id = this._getId();\n\n  var isGoaway = this._isGoaway(id);\n\n  if (uri.push && !state.acceptPush) {\n    state.debug('id=0 push disabled promisedId=%d', id);\n\n    // Fatal error\n    this._goaway({\n      lastId: state.stream.lastId.both,\n      code: 'PROTOCOL_ERROR',\n      send: true\n    });\n    isGoaway = true;\n  }\n\n  var stream = new Stream(this, {\n    id: id,\n    request: uri.request !== false,\n    method: uri.method,\n    path: uri.path,\n    host: uri.host,\n    priority: uri.priority,\n    headers: uri.headers,\n    parent: uri.parent,\n    readable: !isGoaway && uri.readable,\n    writable: !isGoaway && uri.writable\n  });\n  var self = this;\n\n  // Just an empty stream for API consistency\n  if (isGoaway)\n    return stream;\n\n  state.stream.lastId.both = Math.max(state.stream.lastId.both, id);\n\n  state.debug('id=0 add stream=%d', stream.id);\n  state.stream.map[stream.id] = stream;\n  state.stream.count++;\n  state.counters.stream++;\n  if (stream.parent !== null)\n    state.counters.push++;\n\n  stream.once('close', function() {\n    self._removeStream(stream);\n  });\n\n  return stream;\n};\n\nConnection.prototype._handleHeaders = function _handleHeaders(frame) {\n  var state = this._spdyState;\n\n  // Must be HEADERS frame after stream close\n  if (frame.id <= state.stream.lastId.received)\n    return;\n\n  // Someone is using our ids!\n  if ((frame.id + state.stream.nextId) % 2 === 0) {\n    state.framer.rstFrame({ id: frame.id, code: 'PROTOCOL_ERROR' });\n    return;\n  }\n\n  var stream = this._createStream({\n    id: frame.id,\n    request: false,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: frame.writable\n  });\n\n  // GOAWAY\n  if (this._isGoaway(stream.id))\n    return;\n\n  state.stream.lastId.received = Math.max(state.stream.lastId.received,\n                                          stream.id);\n\n  // TODO(indutny) handle stream limit\n  if (!this.emit('stream', stream)) {\n    // No listeners was set - abort the stream\n    stream.abort();\n    return;\n  }\n\n  // Create fake frame to simulate end of the data\n  if (frame.fin)\n    stream._handleFrame({ type: 'FIN', fin: true });\n\n  return stream;\n};\n\nConnection.prototype._onSessionWindowDrain = function _onSessionWindowDrain() {\n  var state = this._spdyState;\n  if (state.version < 3.1 && !(state.isServer && state.autoSpdy31))\n    return;\n\n  var delta = state.window.recv.getDelta();\n  if (delta === 0)\n    return;\n\n  state.debug('id=0 session window drain, update by %d', delta);\n\n  state.framer.windowUpdateFrame({\n    id: 0,\n    delta: delta\n  });\n  state.window.recv.update(delta);\n};\n\nConnection.prototype.start = function start(version) {\n  this._spdyState.parser.setVersion(version);\n};\n\n// Mostly for testing\nConnection.prototype.getVersion = function getVersion() {\n  return this._spdyState.version;\n};\n\nConnection.prototype._handleSettings = function _handleSettings(settings) {\n  var state = this._spdyState;\n\n  state.framer.ackSettingsFrame();\n\n  this._setDefaultWindow(settings);\n  if (settings.max_frame_size)\n    state.framer.setMaxFrameSize(settings.max_frame_size);\n\n  // TODO(indutny): handle max_header_list_size\n  if (settings.header_table_size) {\n    try {\n      state.pair.compress.updateTableSize(settings.header_table_size);\n    } catch (e) {\n      this._goaway({\n        lastId: 0,\n        code: 'PROTOCOL_ERROR',\n        send: true\n      });\n      return;\n    }\n  }\n\n  // HTTP2 clients needs to enable PUSH streams explicitly\n  if (state.protocol.name !== 'spdy') {\n    if (settings.enable_push === undefined)\n      state.framer.enablePush(state.isServer);\n    else\n      state.framer.enablePush(settings.enable_push === 1);\n  }\n\n  // TODO(indutny): handle max_concurrent_streams\n};\n\nConnection.prototype._setDefaultWindow = function _setDefaultWindow(settings) {\n  if (settings.initial_window_size === undefined)\n    return;\n\n  var state = this._spdyState;\n\n  // Update defaults\n  var window = state.streamWindow;\n  window.send.setMax(settings.initial_window_size);\n\n  // Update existing streams\n  Object.keys(state.stream.map).forEach(function(id) {\n    var stream = state.stream.map[id];\n    var window = stream._spdyState.window;\n\n    window.send.updateMax(settings.initial_window_size);\n  });\n};\n\nConnection.prototype._handlePing = function handlePing(frame) {\n  var self = this;\n  var state = this._spdyState;\n\n  // Handle incoming PING\n  if (!frame.ack) {\n    state.framer.pingFrame({\n      opaque: frame.opaque,\n      ack: true\n    });\n\n    self.emit('ping', frame.opaque);\n    return;\n  }\n\n  // Handle reply PING\n  var hex = frame.opaque.toString('hex');\n  if (!state.ping.map[hex])\n    return;\n  var ping = state.ping.map[hex];\n  delete state.ping.map[hex];\n\n  if (ping.cb)\n    ping.cb(null);\n};\n\nConnection.prototype._handleGoaway = function handleGoaway(frame) {\n  this._goaway({\n    lastId: frame.lastId,\n    code: frame.code,\n    send: false\n  });\n};\n\nConnection.prototype.ping = function ping(callback) {\n  var state = this._spdyState;\n\n  // HTTP2 is using 8-byte opaque\n  var opaque = new Buffer(state.constants.PING_OPAQUE_SIZE);\n  opaque.fill(0);\n  opaque.writeUInt32BE(state.ping.nextId, opaque.length - 4);\n  state.ping.nextId += 2;\n\n  state.ping.map[opaque.toString('hex')] = { cb: callback };\n  state.framer.pingFrame({\n    opaque: opaque,\n    ack: false\n  });\n};\n\nConnection.prototype.getCounter = function getCounter(name) {\n  return this._spdyState.counters[name];\n};\n\nConnection.prototype.reserveStream = function reserveStream(uri, callback) {\n  var stream = this._createStream(uri);\n\n  // GOAWAY\n  if (this._isGoaway(stream.id)) {\n    var err = new Error('Can\\'t send request after GOAWAY');\n    process.nextTick(function() {\n      if (callback)\n        callback(err);\n      else\n        stream.emit('error', err);\n    });\n    return stream;\n  }\n\n  if (callback) {\n    process.nextTick(function() {\n      callback(null, stream);\n    });\n  }\n\n  return stream;\n};\n\nConnection.prototype.request = function request(uri, callback) {\n  var stream = this.reserveStream(uri, function(err) {\n    if (err) {\n      if (callback)\n        callback(err);\n      else\n        stream.emit('error', err);\n      return;\n    }\n\n    if (stream._wasSent()) {\n      if (callback)\n        callback(null, stream);\n      return;\n    }\n\n    stream.send(function(err) {\n      if (err) {\n        if (callback)\n          return callback(err);\n        else\n          return stream.emit('error', err);\n      }\n\n      if (callback)\n        callback(null, stream);\n    });\n  });\n\n  return stream;\n};\n\nConnection.prototype._removeStream = function _removeStream(stream) {\n  var state = this._spdyState;\n\n  state.debug('id=0 remove stream=%d', stream.id);\n  delete state.stream.map[stream.id];\n  state.stream.count--;\n\n  if (state.stream.count === 0)\n    this.emit('_streamDrain');\n};\n\nConnection.prototype._goaway = function _goaway(params) {\n  var state = this._spdyState;\n  var self = this;\n\n  state.goaway = params.lastId;\n  state.debug('id=0 goaway from=%d', state.goaway);\n\n  Object.keys(state.stream.map).forEach(function(id) {\n    var stream = state.stream.map[id];\n\n    // Abort every stream started after GOAWAY\n    if (stream.id <= params.lastId)\n      return;\n\n    stream.abort();\n    stream.emit('error', new Error('New stream after GOAWAY'));\n  });\n\n  function finish() {\n    // Destroy socket if there are no streams\n    if (state.stream.count === 0 || params.code !== 'OK') {\n      // No further frames should be processed\n      state.parser.kill();\n\n      process.nextTick(function() {\n        var err = new Error('Fatal error: ' + params.code);\n        self._onStreamDrain(err);\n      });\n      return;\n    }\n\n    self.on('_streamDrain', self._onStreamDrain);\n  }\n\n  if (params.send) {\n    // Make sure that GOAWAY frame is sent before dumping framer\n    state.framer.goawayFrame({\n      lastId: params.lastId,\n      code: params.code,\n      extra: params.extra\n    }, finish);\n  } else {\n    finish();\n  }\n};\n\nConnection.prototype._onStreamDrain = function _onStreamDrain(error) {\n  var state = this._spdyState;\n\n  state.debug('id=0 _onStreamDrain');\n\n  state.framer.dump();\n  state.framer.unpipe(this.socket);\n  state.framer.resume();\n\n  if (this.socket.destroySoon)\n    this.socket.destroySoon();\n  this.emit('close', error);\n};\n\nConnection.prototype.end = function end(callback) {\n  var state = this._spdyState;\n\n  if (callback)\n    this.once('close', callback);\n  this._goaway({\n    lastId: state.stream.lastId.both,\n    code: 'OK',\n    send: true\n  });\n};\n\nConnection.prototype.destroyStreams = function destroyStreams(err) {\n  var state = this._spdyState;\n  Object.keys(state.stream.map).forEach(function(id) {\n    var stream = state.stream.map[id];\n\n    stream.abort();\n    stream.emit('error', err);\n  });\n};\n\nConnection.prototype.isServer = function isServer() {\n  return this._spdyState.isServer;\n};\n\nConnection.prototype.getXForwardedFor = function getXForwardFor() {\n  return this._spdyState.xForward;\n};\n\nConnection.prototype.sendXForwardedFor = function sendXForwardedFor(host) {\n  var state = this._spdyState;\n  if (state.version !== null)\n    state.framer.xForwardedFor({ host: host });\n  else\n    state.xForward = host;\n};\n\nConnection.prototype.pushPromise = function pushPromise(parent, uri, callback) {\n  var state = this._spdyState;\n\n  var stream = this._createStream({\n    request: false,\n    parent: parent,\n    method: uri.method,\n    path: uri.path,\n    host: uri.host,\n    priority: uri.priority,\n    headers: uri.headers,\n    readable: false\n  });\n\n  // TODO(indutny): deduplicate this logic somehow\n  if (this._isGoaway(stream.id)) {\n    var err = new Error('Can\\'t send PUSH_PROMISE after GOAWAY');\n    process.nextTick(function() {\n      if (callback)\n        callback(err);\n      else\n        stream.emit('error', err);\n    });\n    return stream;\n  }\n\n  if (uri.push && !state.acceptPush) {\n    var err = new Error(\n        'Can\\'t send PUSH_PROMISE, other side won\\'t accept it');\n    process.nextTick(function() {\n      if (callback)\n        callback(err);\n      else\n        stream.emit('error', err);\n    });\n    return stream;\n  }\n\n  stream._sendPush(uri.status, uri.response, function(err) {\n    if (!callback) {\n      if (err)\n        stream.emit('error', err);\n      return;\n    }\n\n    if (err)\n      return callback(err);\n    callback(null, stream);\n  });\n\n  return stream;\n};\n\nConnection.prototype.setTimeout = function setTimeout(delay, callback) {\n  var state = this._spdyState;\n\n  state.timeout.set(delay, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-spdy/node_modules/spdy/lib/spdy/server.js":"'use strict';\n\nvar assert = require('assert');\nvar https = require('https');\nvar http = require('http');\nvar tls = require('tls');\nvar net = require('net');\nvar util = require('util');\nvar selectHose = require('select-hose');\nvar transport = require('spdy-transport');\nvar debug = require('debug')('spdy:server');\nvar EventEmitter = require('events').EventEmitter;\n\nvar spdy = require('../spdy');\n\nvar proto = {};\n\nfunction instantiate(base) {\n  function Server(options, handler) {\n    this._init(base, options, handler);\n  }\n  util.inherits(Server, base);\n\n  Server.create = function create(options, handler) {\n    return new Server(options, handler);\n  };\n\n  Object.keys(proto).forEach(function(key) {\n    Server.prototype[key] = proto[key];\n  });\n\n  return Server;\n}\n\nproto._init = function _init(base, options, handler) {\n  var state = {};\n  this._spdyState = state;\n\n  state.options = options.spdy || {};\n\n  var protocols = state.options.protocols || [\n    'h2',\n    'spdy/3.1', 'spdy/3', 'spdy/2',\n    'http/1.1', 'http/1.0'\n  ];\n\n  var actualOptions = util._extend({\n    NPNProtocols: protocols,\n\n    // Future-proof\n    ALPNProtocols: protocols\n  }, options);\n\n  state.secure = this instanceof tls.Server;\n\n  if (state.secure)\n    base.call(this, actualOptions);\n  else\n    base.call(this);\n\n  // Support HEADERS+FIN\n  this.httpAllowHalfOpen = true;\n\n  var event = state.secure ? 'secureConnection' : 'connection';\n\n  state.listeners = this.listeners(event).slice();\n  assert(state.listeners.length > 0, 'Server does not have default listeners');\n  this.removeAllListeners(event);\n\n  if (state.options.plain)\n    this.on(event, this._onPlainConnection);\n  else\n    this.on(event, this._onConnection);\n\n  if (handler)\n    this.on('request', handler);\n\n  debug('server init secure=%d', state.secure);\n};\n\nproto._onConnection = function _onConnection(socket) {\n  var state = this._spdyState;\n\n  var protocol;\n  if (state.secure)\n    protocol = socket.npnProtocol || socket.alpnProtocol;\n\n  this._handleConnection(socket, protocol);\n};\n\nproto._handleConnection = function _handleConnection(socket, protocol) {\n  var state = this._spdyState;\n\n  if (!protocol)\n    protocol = state.options.protocol;\n\n  debug('incoming socket protocol=%j', protocol);\n\n  // No way we can do anything with the socket\n  if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {\n    debug('to default handler it goes');\n    return this._invokeDefault(socket);\n  }\n\n  socket.setNoDelay(true);\n\n  var connection = transport.connection.create(socket, util._extend({\n    protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',\n    isServer: true\n  }, state.options.connection || {}));\n\n  // Set version when we are certain\n  if (protocol === 'http2')\n    connection.start(4);\n  else if (protocol === 'spdy/3.1')\n    connection.start(3.1);\n  else if (protocol === 'spdy/3')\n    connection.start(3);\n  else if (protocol === 'spdy/2')\n    connection.start(2);\n\n  connection.on('error', function() {\n    socket.destroy();\n  });\n\n  var self = this;\n  connection.on('stream', function(stream) {\n    self._onStream(stream);\n  });\n};\n\n// HTTP2 preface\nvar PREFACE = 'PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n';\nvar PREFACE_BUFFER = new Buffer(PREFACE);\n\nfunction hoseFilter(data, callback) {\n  if (data.length < 1)\n    return callback(null, null);\n\n  // SPDY!\n  if (data[0] === 0x80)\n    return callback(null, 'spdy');\n\n  var avail = Math.min(data.length, PREFACE_BUFFER.length);\n  for (var i = 0; i < avail; i++)\n    if (data[i] !== PREFACE_BUFFER[i])\n      return callback(null, 'http/1.1');\n\n  // Not enough bytes to be sure about HTTP2\n  if (avail !== PREFACE_BUFFER.length)\n    return callback(null, null);\n\n  return callback(null, 'h2');\n}\n\nproto._onPlainConnection = function _onPlainConnection(socket) {\n  var hose = selectHose.create(socket, {}, hoseFilter);\n\n  var self = this;\n  hose.on('select', function(protocol, socket) {\n    self._handleConnection(socket, protocol);\n  });\n\n  hose.on('error', function(err) {\n    debug('hose error %j', err.message);\n    socket.destroy();\n  });\n};\n\nproto._invokeDefault = function _invokeDefault(socket) {\n  var state = this._spdyState;\n\n  for (var i = 0; i < state.listeners.length; i++)\n    state.listeners[i].call(this, socket);\n};\n\nproto._onStream = function _onStream(stream) {\n  var state = this._spdyState;\n\n  var handle = spdy.handle.create(this._spdyState.options, stream);\n\n  var socketOptions = {\n    handle: handle,\n    allowHalfOpen: true\n  };\n\n  var socket;\n  if (state.secure)\n    socket = new spdy.Socket(stream.connection.socket, socketOptions);\n  else\n    socket = new net.Socket(socketOptions);\n\n  handle.assignSocket(socket);\n\n  // For v0.8\n  socket.readable = true;\n  socket.writable = true;\n\n  this._invokeDefault(socket);\n\n  // Add lazy `checkContinue` listener, otherwise `res.writeContinue` will be\n  // called before the response object was patched by us.\n  if (stream.headers.expect !== undefined &&\n      /100-continue/i.test(stream.headers.expect) &&\n      EventEmitter.listenerCount(this, 'checkContinue') === 0) {\n    this.once('checkContinue', function(req, res) {\n      res.writeContinue();\n\n      this.emit('request', req, res);\n    });\n  }\n\n  handle.emitRequest();\n};\n\nproto.emit = function emit(event, req, res) {\n  if (event !== 'request' && event !== 'checkContinue')\n    return EventEmitter.prototype.emit.apply(this, arguments);\n\n  if (!(req.socket._handle instanceof spdy.handle)) {\n    debug('not spdy req/res');\n    req.isSpdy = false;\n    req.spdyVersion = 1;\n    res.isSpdy = false;\n    res.spdyVersion = 1;\n    return EventEmitter.prototype.emit.apply(this, arguments);\n  }\n\n  var handle = req.connection._handle;\n\n  req.isSpdy = true;\n  req.spdyVersion = handle.getStream().connection.getVersion();\n  res.isSpdy = true;\n  res.spdyVersion = req.spdyVersion;\n  req.spdyStream = handle.getStream();\n\n  debug('override req/res');\n  res.writeHead = spdy.response.writeHead;\n  res.end = spdy.response.end;\n  res.push = spdy.response.push;\n  res.writeContinue = spdy.response.writeContinue;\n  res.spdyStream = handle.getStream();\n\n  res._req = req;\n\n  handle.assignRequest(req);\n  handle.assignResponse(res);\n\n  return EventEmitter.prototype.emit.apply(this, arguments);\n};\n\nexports.Server = instantiate(https.Server);\nexports.PlainServer = instantiate(http.Server);\n\nexports.create = function create(base, options, handler) {\n  if (typeof base === 'object') {\n    handler = options;\n    options = base;\n    base = null;\n  }\n\n  if (base)\n    return instantiate(base).create(options, handler);\n\n  if (options.spdy && options.spdy.plain)\n    return exports.PlainServer.create(options, handler);\n  else\n    return exports.Server.create(options, handler);\n};\n"}